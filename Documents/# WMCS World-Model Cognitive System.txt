# WMCS: World-Model Cognitive System
## Complete Technical Specification v1.0

---

# Table of Contents

1. [The Core Problem](#1-the-core-problem)
2. [The Solution: Two-Brain Architecture](#2-the-solution-two-brain-architecture)
3. [Constructive Understanding](#3-constructive-understanding)
4. [The Complete Type System](#4-the-complete-type-system)
5. [The Universal Category System](#5-the-universal-category-system)
6. [Category Field Specifications](#6-category-field-specifications)
7. [The Type Categorization Engine](#7-the-type-categorization-engine)
8. [The Data Filling System](#8-the-data-filling-system)
9. [The Relationship System](#9-the-relationship-system)
10. [The Analogy Engine](#10-the-analogy-engine)
11. [The Logic Engine](#11-the-logic-engine)
12. [Grounding and Confidence](#12-grounding-and-confidence)
13. [Variance and Inheritance](#13-variance-and-inheritance)
14. [The Cognitive Loop](#14-the-cognitive-loop)
15. [Complete Examples](#15-complete-examples)

---

# 1. The Core Problem

## 1.1 Why LLMs Fail

Large Language Models have two fundamental flaws:

**Hallucination**: They make things up. They generate plausible-sounding text that has no basis in reality.

**Amnesia**: They forget things. They have no persistent memory across conversations, and even within a conversation, they lose track of what they've said.

## 1.2 The Root Cause

LLMs have only ever encountered **descriptions**. They've read millions of sentences about cats, but they've never **seen** a cat.

When an LLM "knows" about cats, it has:
- Pattern associations between words
- No perceptual anchor
- No "I've seen this with my own eyes" certainty

This is why they can be confidently wrong. There's no bedrock. It's descriptions all the way down.

## 1.3 How Humans Understand

Humans understand because we **perceive**. We see a cat, we *know* it's a cat. We can't unsee it. The perceptual grounding creates certainty that's different from logical deduction.

**Surface Knowledge (Immediate)**:
- What it looks like
- What it sounds like
- Basic behaviors you've observed
- This is *fast*. You just know.

**Deep Knowledge (Requires Thought)**:
- How does it work internally?
- Why does it behave that way?
- What are the non-obvious implications?
- This is *slow*. You have to think.

**Critical Insight**: Deep knowledge is anchored to surface knowledge. When you learn that cats have retractable claws, you're attaching that fact to something you've already *seen*. The deep knowledge inherits the grounding of the surface knowledge.

---

# 2. The Solution: Two-Brain Architecture

## 2.1 The Division

**System A (Left Brain)**: The Cognitive Engine
- Role: Logic, Memory, Fact-Checking, Navigation
- Nature: Deterministic, slow, verifiable
- Components: Concept Store, Vector Memory, Navigator, Logic Engine, Epistemic Gate

**System B (Right Brain)**: The LLM
- Role: Language, Creativity, Synthesis, Reasoning
- Nature: Probabilistic, fast, creative
- Constraint: FORBIDDEN from guessing facts. Must use System A's data.

## 2.2 The Workflow

**System A retrieves everything relevant, fast:**
- Primary concepts
- Related concepts (graph walk)
- Contradictory claims if they exist
- Temporal context, spatial constraints, relevant facets
- Delivers as a structured context packet

**System B reasons over that verified foundation:**
- Synthesize across concepts
- Find non-obvious connections
- Think laterally, abstractly, metaphorically
- Generate hypotheses
- Argue with itself from multiple angles

The LLM can think as creatively as it wants because it's not responsible for *being* the database. It reasons over facts, not trying to be facts.

## 2.3 What This Enables

**Grounded Chain-of-Thought**: Each reasoning step lands on a verified concept. The path is auditable. No drift into hallucination.

**Iterative Reasoning**: Fast retrieval enables: retrieve → reason → notice gap → retrieve more → continue → synthesize. Multiple loops per response.

**Analogical Reasoning**: "How is X like Y?" → Retrieve both with full facets → LLM compares on solid ground.

**Counterfactual Reasoning**: "If X were true, what follows?" → Temporarily inject claim → Walk implications → Report conflicts.

---

# 3. Constructive Understanding

## 3.1 The Principle

Understanding is not just knowing facts about something. It's knowing how to **construct** it from primitives.

Not just "cat has skeleton."
It's: cat is *constructed from* skeleton, and skeleton is *constructed from* bone, traceable down to base elements.

Not just "cat has ears."
It's: ears exist at *this specific spatial relationship* to the head, which exists at *this specific relationship* to the body. Geometry is explicit.

## 3.2 What This Enables

Questions that LLMs cannot reliably answer become calculable:

| Question | How WMCS Answers |
|----------|------------------|
| "If a cat tilts its head 45°, where are the ears?" | Coordinate transform on spatial structure |
| "Could a cat fit through a 10cm hole?" | Check body dimensions, calculate compression |
| "What's between a cat's brain and outside?" | Trace: Brain → Skull → Skin → Fur |
| "Why do cat bones break?" | Walk composition: Bone → Calcium + Collagen → material properties |

## 3.3 The Center Point

Every physical concept has a **center** that other parts are defined relative to.

**For creatures/bodies**: Center of mass. It's where physics actually acts.

**For objects**: Geometric center.

**For abstract concepts**: The core idea that everything else attaches to. Or no center (for truly distributed concepts).

**Rule**: The center is whatever the other parts are defined relative to. Pick it based on what makes the relational descriptions simplest.

---

# 4. The Complete Type System

## 4.1 Why Types Matter

Different kinds of concepts need different categories. A cat needs spatial structure. A song needs temporal structure. Democracy needs hierarchical structure. The type determines what data the system needs to collect.

## 4.2 The Full Type Tree

```
TYPES:
│
├── PHYSICAL
│   ├── organism
│   │   ├── organism.plant
│   │   ├── organism.animal
│   │   │   ├── organism.animal.mammal
│   │   │   ├── organism.animal.bird
│   │   │   ├── organism.animal.reptile
│   │   │   ├── organism.animal.fish
│   │   │   └── organism.animal.invertebrate
│   │   ├── organism.fungi
│   │   └── organism.microorganism
│   │
│   ├── natural_object
│   │   ├── natural_object.geological (rock, mineral, mountain)
│   │   ├── natural_object.astronomical (star, planet, moon)
│   │   ├── natural_object.atmospheric (cloud, storm)
│   │   └── natural_object.water_body (ocean, river, lake)
│   │
│   ├── artifact.physical
│   │   ├── artifact.physical.tool
│   │   ├── artifact.physical.vehicle
│   │   ├── artifact.physical.building
│   │   ├── artifact.physical.furniture
│   │   ├── artifact.physical.clothing
│   │   └── artifact.physical.container
│   │
│   ├── artifact.temporal
│   │   ├── artifact.temporal.music (song, symphony)
│   │   ├── artifact.temporal.video (film, show)
│   │   ├── artifact.temporal.performance (play, dance)
│   │   └── artifact.temporal.broadcast (podcast, radio show)
│   │
│   └── place
│       ├── place.natural (forest, desert, cave)
│       ├── place.constructed (city, building, room)
│       └── place.conceptual (country, territory, zone)
│
├── EVENT_LIKE
│   ├── event
│   │   ├── event.moment (explosion, birth, death)
│   │   ├── event.period (war, meeting, party)
│   │   └── event.continuous (climate change, evolution)
│   │
│   ├── process
│   │   ├── process.instructional (recipe, algorithm, protocol)
│   │   ├── process.natural (digestion, photosynthesis)
│   │   └── process.social (election, trial, negotiation)
│   │
│   └── phenomenon
│       ├── phenomenon.physical (electricity, magnetism, gravity_effect)
│       ├── phenomenon.weather (rain, storm, tornado)
│       ├── phenomenon.optical (rainbow, mirage)
│       └── phenomenon.social (trend, movement, panic)
│
├── SYSTEM
│   ├── system.governance
│   │   ├── system.governance.political (democracy, monarchy)
│   │   ├── system.governance.legal (common law, civil law)
│   │   └── system.governance.economic (capitalism, socialism)
│   │
│   ├── system.interactive
│   │   ├── system.interactive.game (chess, poker, video game)
│   │   ├── system.interactive.conversation
│   │   ├── system.interactive.negotiation
│   │   └── system.interactive.ritual
│   │
│   ├── system.language
│   │   ├── system.language.natural (English, Mandarin)
│   │   ├── system.language.formal (mathematics, logic)
│   │   └── system.language.programming (Python, JavaScript)
│   │
│   └── system.technical
│       ├── system.technical.mechanical
│       ├── system.technical.electrical
│       ├── system.technical.software
│       └── system.technical.network
│
├── AGENT_ATTACHED
│   ├── organization
│   │   ├── organization.corporate (company, startup)
│   │   ├── organization.governmental (agency, department)
│   │   ├── organization.social (club, team, family)
│   │   └── organization.religious (church, temple)
│   │
│   ├── pattern
│   │   ├── pattern.habit (personal repeated behavior)
│   │   ├── pattern.tradition (cultural repeated behavior)
│   │   ├── pattern.routine (structured sequence)
│   │   └── pattern.addiction (compulsive pattern)
│   │
│   ├── ability
│   │   ├── ability.physical (swimming, running)
│   │   ├── ability.cognitive (reading, calculating)
│   │   ├── ability.social (persuading, leading)
│   │   └── ability.creative (painting, composing)
│   │
│   └── state
│       ├── state.physical (asleep, injured, pregnant)
│       ├── state.emotional (happy, sad, angry)
│       ├── state.social (married, employed, at_war)
│       └── state.phase (solid, liquid, gas)
│
├── EXPERIENCE
│   ├── experience.emotion
│   │   ├── experience.emotion.basic (joy, sadness, fear, anger)
│   │   ├── experience.emotion.complex (love, grief, jealousy)
│   │   └── experience.emotion.social (embarrassment, pride)
│   │
│   ├── experience.sensation
│   │   ├── experience.sensation.pain
│   │   ├── experience.sensation.pleasure
│   │   ├── experience.sensation.hunger
│   │   ├── experience.sensation.temperature
│   │   └── experience.sensation.pressure
│   │
│   └── experience.cognitive
│       ├── experience.cognitive.memory
│       ├── experience.cognitive.deja_vu
│       ├── experience.cognitive.insight
│       └── experience.cognitive.confusion
│
├── PROPERTY
│   ├── property.sensory
│   │   ├── property.sensory.color
│   │   ├── property.sensory.sound
│   │   ├── property.sensory.texture
│   │   ├── property.sensory.taste
│   │   └── property.sensory.smell
│   │
│   ├── property.relational
│   │   ├── property.relational.price
│   │   ├── property.relational.distance
│   │   ├── property.relational.similarity
│   │   └── property.relational.rank
│   │
│   └── property.intrinsic
│       ├── property.intrinsic.mass
│       ├── property.intrinsic.age
│       ├── property.intrinsic.density
│       └── property.intrinsic.temperature
│
├── ABSTRACT
│   ├── abstraction.formal
│   │   ├── abstraction.formal.number
│   │   ├── abstraction.formal.shape
│   │   ├── abstraction.formal.set
│   │   ├── abstraction.formal.function
│   │   └── abstraction.formal.logical_operator
│   │
│   ├── abstraction.conceptual
│   │   ├── abstraction.conceptual.philosophical (justice, truth)
│   │   ├── abstraction.conceptual.social (freedom, equality)
│   │   └── abstraction.conceptual.aesthetic (beauty, elegance)
│   │
│   ├── category
│   │   ├── category.taxonomic (species, genus)
│   │   ├── category.genre (music genre, literary genre)
│   │   └── category.classification (type, kind, class)
│   │
│   └── relation
│       ├── relation.causal (cause-effect)
│       ├── relation.compositional (part-whole)
│       ├── relation.hierarchical (parent-child)
│       └── relation.associative (related-to)
│
├── META
│   ├── reference
│   │   ├── reference.temporal (tomorrow, last year)
│   │   ├── reference.spatial (here, nearby)
│   │   ├── reference.possessive (my house, the president)
│   │   └── reference.demonstrative (this, that)
│   │
│   ├── potential
│   │   ├── potential.possibility (what could happen)
│   │   ├── potential.risk (negative potential)
│   │   ├── potential.opportunity (positive potential)
│   │   └── potential.plan (intended future)
│   │
│   └── composite
│       ├── composite.dream
│       ├── composite.story
│       ├── composite.scenario
│       └── composite.plan
│
├── STRUCTURAL
│   ├── absence
│   │   ├── absence.spatial (hole, gap, void)
│   │   ├── absence.temporal (silence, pause)
│   │   └── absence.conceptual (lack, deficiency)
│   │
│   ├── boundary
│   │   ├── boundary.physical (edge, border, wall)
│   │   ├── boundary.conceptual (limit, threshold)
│   │   └── boundary.social (rule, taboo)
│   │
│   └── law
│       ├── law.physical (gravity, thermodynamics)
│       ├── law.biological (evolution, genetics)
│       ├── law.economic (supply-demand)
│       └── law.social (norms, conventions)
│
└── LINGUISTIC
    ├── linguistic.speech_act
    │   ├── linguistic.speech_act.assertive (statement, claim)
    │   ├── linguistic.speech_act.directive (question, command)
    │   ├── linguistic.speech_act.commissive (promise, threat)
    │   ├── linguistic.speech_act.expressive (apology, thanks)
    │   └── linguistic.speech_act.declarative (pronouncement, naming)
    │
    └── linguistic.unit
        ├── linguistic.unit.word
        ├── linguistic.unit.phrase
        ├── linguistic.unit.sentence
        └── linguistic.unit.text
```

## 4.3 Structure Type by Concept Type

Different types have different primary organizational structures:

| Type | Primary Structure | Center/Origin |
|------|------------------|---------------|
| organism | Spatial (body parts in 3D) | Body core / center of mass |
| artifact.physical | Spatial (components in 3D) | Geometric center |
| artifact.temporal | Temporal (segments in sequence) | Start point (0:00) |
| event | Temporal + Spatial | Start moment + trigger location |
| process | Sequential (ordered steps) | First step |
| phenomenon | Causal + Conditions | Trigger conditions |
| system.governance | Hierarchical (power flow) | Power source |
| system.interactive | State-based (rules + states) | Initial state |
| organization | Hierarchical (roles + structure) | Leadership |
| experience.emotion | Manifestation (how it expresses) | The experiencer |
| experience.sensation | Body-located | Body part |
| property.sensory | Definitional (physical basis) | What it attaches to |
| property.relational | Between-ness | The related items |
| abstraction.formal | Axiomatic (formal definitions) | Core axioms |
| abstraction.conceptual | Definitional | Core meaning |
| category | Membership criteria | The criteria |
| relation | Directionality | The connected concepts |
| reference | Context-dependent | Current context |
| potential | Conditional | The conditions |
| composite | Nested structure | The frame/container |
| absence | Boundary-defined | The surrounding material |
| boundary | Edge-defined | What it separates |
| law | Domain-defined | Domain of application |
| linguistic | Functional structure | Speaker/Listener context |

---

# 5. The Universal Category System

## 5.1 Overview

Every concept can have these categories. Not all apply to every type. The type determines which are required, recommended, or optional.

## 5.2 Complete Category List

```
CATEGORIES:
│
├── CORE (Every concept)
│   ├── id
│   ├── name
│   ├── aliases
│   ├── type
│   ├── definition
│   └── grounding
│
├── CLASSIFICATION
│   ├── categorical (type hierarchy chain)
│   └── tags (flexible labels)
│
├── SUBSTANCE
│   ├── composition (what it's made of)
│   └── components (functional parts - for non-physical)
│
├── ARRANGEMENT
│   ├── structure_spatial (3D arrangement)
│   ├── structure_temporal (time-based arrangement)
│   ├── structure_hierarchical (power/org arrangement)
│   └── structure_definitional (formal/logical arrangement)
│
├── PERCEPTION
│   ├── surface (how it appears to senses)
│   └── manifestation (how experiences express)
│
├── ATTRIBUTES
│   ├── properties_physical (measurable)
│   ├── properties_intrinsic (inherent qualities)
│   ├── properties_abstract (assigned/derived)
│   └── properties_variable (changing over time)
│
├── DYNAMICS
│   ├── behavior (what it does)
│   ├── function (what it's for)
│   └── capabilities (what it can do)
│
├── TIME
│   ├── temporal_lifecycle (stages of existence)
│   ├── temporal_states (temporary conditions)
│   └── temporal_duration (lifespan/length)
│
├── CAUSATION
│   ├── causal_requires (dependencies)
│   ├── causal_produces (outputs)
│   ├── causal_causes (effects)
│   ├── causal_caused_by (origins)
│   └── causal_prevents (blocking)
│
├── CONNECTIONS
│   ├── relational (links to other concepts)
│   ├── contrasts_with (opposites/alternatives)
│   ├── similar_to (analogues)
│   ├── part_of (larger wholes)
│   └── contains (smaller parts)
│
├── CONTEXT
│   ├── contextual_location (where)
│   ├── contextual_conditions (under what circumstances)
│   ├── contextual_distribution (geographic/temporal spread)
│   └── contextual_cultural (cultural associations)
│
├── VARIATION
│   ├── variance (how much it can differ)
│   ├── variants (subtypes with differences)
│   └── instances (specific examples)
│
├── SPECIAL (Type-specific)
│   ├── participants (for events, systems)
│   ├── rules (for systems, games)
│   ├── steps (for processes)
│   ├── inputs/outputs (for processes)
│   ├── triggers (for patterns, sensations)
│   ├── representations (for abstractions)
│   ├── associations (for properties, concepts)
│   └── members/criteria (for categories)
│
└── META
    ├── reasoning_hooks (what to retrieve for what query)
    ├── confidence (overall reliability)
    └── flags (issues, incomplete, needs_review)
```

---

# 6. Category Field Specifications

## 6.1 CORE Fields (Every Concept)

```json
{
  "id": {
    "format": "(group.item) or (group.item.subitem)",
    "example": "20.1004",
    "description": "Unique identifier. Group = domain, Item = concept number",
    "required": true
  },
  
  "name": {
    "format": "string",
    "example": "Cat",
    "description": "Primary label for the concept",
    "required": true
  },
  
  "aliases": {
    "format": ["string array"],
    "example": ["feline", "kitty", "house cat", "Felis catus"],
    "description": "Other names, synonyms, scientific names",
    "required": false
  },
  
  "type": {
    "format": "type.path.string",
    "example": "organism.animal.mammal",
    "description": "From the type tree",
    "required": true
  },
  
  "definition": {
    "format": "string (one sentence)",
    "example": "A small domesticated carnivorous mammal with soft fur, retractable claws, and keen senses.",
    "description": "Clear, concise definition. Should allow someone to distinguish this from similar concepts.",
    "required": true
  }
}
```

## 6.2 GROUNDING Fields

```json
{
  "grounding": {
    "chain": {
      "format": ["array of steps to base"],
      "example": ["Cat → directly observable → millions of photographs + specimens"],
      "description": "How we know this exists. Trace back to something solid."
    },
    
    "base_types": {
      "format": ["array of grounding types"],
      "options": ["perceptual", "measurement", "logical", "behavioral", "attestation"],
      "example": ["perceptual", "measurement"],
      "description": "What kind of evidence grounds this concept"
    },
    
    "evidence_summary": {
      "format": "string",
      "example": "Directly observable animal with millions of documented specimens, photographs, and scientific studies.",
      "description": "Brief description of the evidence"
    },
    
    "weakest_link": {
      "format": "string or null",
      "example": null,
      "description": "Where the grounding chain is most uncertain"
    },
    
    "confidence": {
      "format": "float 0.0-1.0",
      "example": 0.99,
      "description": "Overall confidence in this concept's validity"
    }
  }
}
```

### Grounding Types Explained

| Type | Description | Example |
|------|-------------|---------|
| perceptual | Can be directly observed with senses or cameras | Cat, red color, thunder |
| measurement | Can be measured with instruments | Mass, temperature, wavelength |
| logical | Follows necessarily from axioms/definitions | Numbers, geometric shapes |
| behavioral | Repeatedly observed statistical regularity | "Cats hunt mice" |
| attestation | Trusted humans/sources confirm | Historical events, expert knowledge |

### Grounding Chain Depth

| Depth | Meaning | Example |
|-------|---------|---------|
| 0 | Axiomatic / directly defined | Number 7 |
| 1 | Directly observable | Cat |
| 2 | One step removed | Love (observed via manifestations) |
| 3 | Two steps removed | Justice (observed via institutions → behaviors) |
| 4+ | Highly abstract | Democracy → institutions → behaviors → physical |

## 6.3 CATEGORICAL Fields

```json
{
  "categorical": {
    "chain": {
      "format": ["array from specific to general"],
      "example": ["cat", "feline", "carnivore", "mammal", "animal", "organism", "living thing", "physical object", "entity"],
      "description": "The IS_A hierarchy. Each item is a type of the next."
    },
    
    "siblings": {
      "format": ["array of same-level concepts"],
      "example": ["dog", "bear", "seal", "raccoon"],
      "description": "Other concepts at the same level (other carnivores)"
    },
    
    "distinguishing_features": {
      "format": ["array of features"],
      "example": ["retractable claws", "obligate carnivore", "solitary hunter", "domesticated"],
      "description": "What makes this different from siblings"
    }
  }
}
```

## 6.4 COMPOSITION Fields

```json
{
  "composition": {
    "levels": [
      {
        "depth": 0,
        "name": "Organ Systems",
        "components": [
          {
            "name": "Skeletal System",
            "ref": "8.401.skeletal",
            "quantity": "one",
            "essential": true
          },
          {
            "name": "Muscular System",
            "ref": "8.401.muscular",
            "quantity": "one",
            "essential": true
          }
        ]
      },
      {
        "depth": 1,
        "name": "Organs",
        "components": [
          {
            "name": "Heart",
            "ref": "8.301.heart",
            "quantity": "one",
            "essential": true
          }
        ]
      },
      {
        "depth": 2,
        "name": "Tissues",
        "components": []
      },
      {
        "depth": 3,
        "name": "Cells",
        "components": []
      }
    ],
    
    "base_layer": {
      "domain": "biology",
      "concept": "cell",
      "ref": "8.101",
      "description": "Composition chain stops here for biological concepts"
    },
    
    "assembly": {
      "format": "string",
      "example": "Cells form tissues, tissues form organs, organs form organ systems, organ systems form organism",
      "description": "How components combine"
    }
  }
}
```

### Base Layers by Domain

```json
{
  "base_layers": {
    "biology": ["cell", "protein", "DNA", "basic_molecules"],
    "materials": ["wood", "metal", "plastic", "glass", "ceramic", "fabric"],
    "chemistry": ["molecule", "atom", "element"],
    "physics": ["mass", "energy", "force", "space", "time"],
    "computing": ["bit", "logic_gate", "transistor"],
    "social": ["individual_human", "action", "communication"]
  }
}
```

**Rule**: Go deep enough to explain the behaviors you care about. No deeper. If you need to explain why bones break, you need calcium and collagen. You don't need quarks.

## 6.5 STRUCTURE Fields

### 6.5.1 Spatial Structure (Physical Things)

```json
{
  "structure_spatial": {
    "center": {
      "name": "body_core",
      "description": "Central reference point for all positions",
      "position": {"x": 0, "y": 0, "z": 0}
    },
    
    "overall": {
      "shape": "quadruped_form",
      "size": {
        "length": {"value": 45, "unit": "cm", "variance": "±15%"},
        "width": {"value": 20, "unit": "cm", "variance": "±15%"},
        "height": {"value": 25, "unit": "cm", "variance": "±15%"}
      },
      "volume_approx": {"value": 22500, "unit": "cm³"}
    },
    
    "parts": [
      {
        "name": "head",
        "ref": "20.1004.head",
        "relative_to": "body_core",
        "position": {"x": 25, "y": 0, "z": 10, "unit": "cm"},
        "rotation": {"pitch": 0, "yaw": 0, "roll": 0},
        "connection": {
          "type": "flexible_joint",
          "via": "neck",
          "degrees_of_freedom": {"pitch": 90, "yaw": 180, "roll": 45}
        },
        "shape": "round",
        "size": {"diameter": 10, "unit": "cm"}
      },
      {
        "name": "ears",
        "ref": "20.1004.ear",
        "quantity": 2,
        "relative_to": "head",
        "positions": [
          {"x": 3, "y": 0, "z": 5, "side": "left"},
          {"x": -3, "y": 0, "z": 5, "side": "right"}
        ],
        "angle": {"value": 45, "unit": "degrees", "direction": "outward"},
        "shape": "triangular",
        "size": {"height": 5, "width": 4, "unit": "cm"},
        "movable": true
      },
      {
        "name": "legs",
        "ref": "20.1004.leg",
        "quantity": 4,
        "relative_to": "body_core",
        "positions": [
          {"x": 15, "y": 8, "z": -12, "label": "front_left"},
          {"x": 15, "y": -8, "z": -12, "label": "front_right"},
          {"x": -15, "y": 8, "z": -12, "label": "back_left"},
          {"x": -15, "y": -8, "z": -12, "label": "back_right"}
        ],
        "joints": [
          {"name": "hip/shoulder", "degrees_of_freedom": 120},
          {"name": "knee/elbow", "degrees_of_freedom": 140},
          {"name": "ankle/wrist", "degrees_of_freedom": 90}
        ],
        "terminates_in": "paw"
      },
      {
        "name": "tail",
        "ref": "20.1004.tail",
        "relative_to": "body_core",
        "position": {"x": -25, "y": 0, "z": 0},
        "length": {"value": 25, "unit": "cm"},
        "flexible": true,
        "segments": "multiple_vertebrae"
      }
    ],
    
    "symmetry": {
      "type": "bilateral",
      "axis": "y"
    }
  }
}
```

### 6.5.2 Temporal Structure (Time-Based Things)

```json
{
  "structure_temporal": {
    "origin": {
      "type": "start_point",
      "value": "0:00",
      "description": "All segment times relative to this"
    },
    
    "total_duration": {
      "typical": {"value": 3.5, "unit": "minutes"},
      "range": {"min": 2, "max": 7, "unit": "minutes"}
    },
    
    "segments": [
      {
        "name": "intro",
        "position": {"start": "0:00", "end": "0:15"},
        "duration": {"value": 15, "unit": "seconds"},
        "follows": null,
        "precedes": "verse_1",
        "characteristics": ["instrumental", "establishes_key"]
      },
      {
        "name": "verse_1",
        "position": {"start": "0:15", "end": "0:45"},
        "duration": {"value": 30, "unit": "seconds"},
        "follows": "intro",
        "precedes": "chorus_1",
        "characteristics": ["vocals_begin", "narrative_setup"]
      },
      {
        "name": "chorus_1",
        "position": {"start": "0:45", "end": "1:15"},
        "duration": {"value": 30, "unit": "seconds"},
        "follows": "verse_1",
        "precedes": "verse_2",
        "characteristics": ["main_hook", "emotional_peak"]
      }
    ],
    
    "pattern": {
      "repeating_unit": ["verse", "chorus"],
      "variations": ["bridge_before_final_chorus"]
    }
  }
}
```

### 6.5.3 Hierarchical Structure (Systems, Organizations)

```json
{
  "structure_hierarchical": {
    "root": {
      "name": "Constitution",
      "description": "Ultimate source of authority"
    },
    
    "levels": [
      {
        "level": 0,
        "name": "Citizens",
        "members": "all_eligible_voters",
        "power": "elect representatives, amend constitution",
        "reports_to": "Constitution"
      },
      {
        "level": 1,
        "name": "Elected Representatives",
        "members": ["legislators", "executive"],
        "power": "make laws, enforce laws",
        "reports_to": "Citizens (via elections)"
      },
      {
        "level": 2,
        "name": "Government Agencies",
        "members": "appointed officials, civil servants",
        "power": "implement laws",
        "reports_to": "Elected Representatives"
      }
    ],
    
    "flow": {
      "power": "citizens → representatives → agencies → citizens (circular)",
      "information": "bidirectional with transparency requirements",
      "resources": "taxes up, services down"
    },
    
    "checks": [
      {
        "between": ["legislative", "executive"],
        "mechanism": "veto and override"
      },
      {
        "between": ["judicial", "legislative"],
        "mechanism": "constitutional review"
      }
    ]
  }
}
```

### 6.5.4 Definitional Structure (Abstract/Formal)

```json
{
  "structure_definitional": {
    "axioms": [
      "7 is the successor of 6",
      "7 is the predecessor of 8",
      "7 is a natural number"
    ],
    
    "derived_properties": [
      {"property": "odd", "derivation": "7 mod 2 = 1"},
      {"property": "prime", "derivation": "factors are only 1 and 7"}
    ],
    
    "relationships": {
      "equals": ["6+1", "8-1", "14/2", "49^0.5 (approx)"],
      "less_than": ["8", "9", "10", "..."],
      "greater_than": ["6", "5", "4", "..."]
    },
    
    "constraints": [
      "Cannot be both odd and even",
      "Has exactly two factors (being prime)"
    ]
  }
}
```

## 6.6 SURFACE / MANIFESTATION Fields

### 6.6.1 Surface (Physical Things)

```json
{
  "surface": {
    "visual": {
      "colors": {
        "common": ["orange", "gray", "black", "white"],
        "patterns": ["solid", "tabby", "calico", "tuxedo", "pointed"]
      },
      "shape_impression": "small quadruped with rounded features",
      "distinctive_features": ["pointed ears", "whiskers", "vertical pupils", "long tail"],
      "texture_appearance": "furry"
    },
    
    "auditory": {
      "sounds_produced": [
        {"name": "meow", "context": "communication with humans", "frequency": "variable"},
        {"name": "purr", "context": "contentment or self-soothing", "frequency": "25-150 Hz"},
        {"name": "hiss", "context": "threat/fear", "frequency": "high"}
      ],
      "sounds_movement": "usually silent (padded feet)"
    },
    
    "tactile": {
      "texture": "soft fur over firm body",
      "temperature": "warm (38°C body temp)",
      "notable": "rough tongue (papillae)"
    },
    
    "olfactory": {
      "smell": "mild, distinctive 'cat smell'",
      "notable": "urine has strong odor (territorial marking)"
    },
    
    "size_impression": "small, fits in lap, can be held",
    
    "overall_gestalt": "Small, soft, agile predator with alert, independent demeanor"
  }
}
```

### 6.6.2 Manifestation (Experiences/Emotions)

```json
{
  "manifestation": {
    "physical_signs": [
      {"sign": "increased heart rate", "intensity_correlation": "positive"},
      {"sign": "warmth in chest", "intensity_correlation": "positive"},
      {"sign": "tears (when intense)", "context": "overwhelming love or loss"},
      {"sign": "desire for physical proximity", "intensity_correlation": "positive"}
    ],
    
    "behavioral_signs": [
      {"sign": "seeking presence of loved one", "frequency": "persistent"},
      {"sign": "protective actions", "context": "perceived threat to loved one"},
      {"sign": "sacrifice of self-interest", "context": "benefit to loved one"},
      {"sign": "gift-giving", "context": "expression of care"},
      {"sign": "physical affection", "forms": ["hugging", "kissing", "hand-holding"]}
    ],
    
    "cognitive_signs": [
      {"sign": "preoccupation with loved one", "frequency": "frequent thoughts"},
      {"sign": "idealization", "description": "focus on positive qualities"},
      {"sign": "future planning involving loved one", "description": "shared future orientation"},
      {"sign": "empathic concern", "description": "distress at loved one's distress"}
    ],
    
    "subjective_quality": "Warmth, fullness, sense of connection, vulnerability, and desire for the wellbeing of the other"
  }
}
```

## 6.7 PROPERTIES Fields

```json
{
  "properties": {
    "physical": {
      "mass": {
        "typical": {"value": 4.5, "unit": "kg"},
        "range": {"min": 2.5, "max": 7, "unit": "kg"},
        "measurement_method": "scale"
      },
      "body_temperature": {
        "typical": {"value": 38.5, "unit": "°C"},
        "range": {"min": 37.5, "max": 39.5, "unit": "°C"}
      },
      "heart_rate": {
        "resting": {"value": 140, "unit": "bpm"},
        "range": {"min": 120, "max": 180, "unit": "bpm"}
      }
    },
    
    "intrinsic": {
      "intelligence": {"level": "high for animals", "evidence": "problem-solving, learning"},
      "sociability": {"level": "variable", "range": "solitary to social"},
      "lifespan_typical": {"value": 15, "unit": "years", "range": {"min": 12, "max": 20}}
    },
    
    "abstract": {
      "domestication_level": {"value": "high", "scale": "wild→feral→semi-domestic→domestic"},
      "danger_to_humans": {"value": "low", "exceptions": "scratches, bites, allergies"},
      "cultural_significance": {"value": "high", "examples": ["pets", "internet culture", "ancient Egypt"]}
    },
    
    "variable": {
      "hunger": {"range": [0, 1], "description": "Current hunger level"},
      "energy": {"range": [0, 1], "description": "Current energy/alertness"},
      "mood": {"range": ["fearful", "calm", "playful", "aggressive"], "description": "Current emotional state"}
    }
  }
}
```

## 6.8 BEHAVIOR Fields

```json
{
  "behavior": {
    "actions": [
      {
        "name": "hunting",
        "description": "Stalking, pouncing, capturing prey",
        "frequency": "instinctual, regular if outdoor",
        "conditions": "presence of prey-like movement",
        "sequence": ["stalk", "crouch", "wiggle", "pounce", "capture", "kill_bite"]
      },
      {
        "name": "grooming",
        "description": "Licking fur to clean and regulate temperature",
        "frequency": "multiple times daily",
        "duration": "minutes to hours",
        "conditions": "awake, relaxed"
      },
      {
        "name": "sleeping",
        "description": "Rest periods",
        "frequency": "12-16 hours per day",
        "conditions": "safe, comfortable location"
      }
    ],
    
    "reactions": [
      {
        "trigger": "loud sudden noise",
        "response": "startle, flee, or freeze",
        "reliability": "almost always"
      },
      {
        "trigger": "stranger approaching",
        "response": "assess, possibly flee or hide",
        "reliability": "usually"
      },
      {
        "trigger": "petting (by trusted human)",
        "response": "purring, relaxation, possible kneading",
        "reliability": "usually"
      },
      {
        "trigger": "cornered by threat",
        "response": "hiss, arch back, swipe with claws",
        "reliability": "almost always"
      }
    ],
    
    "capabilities": [
      "jump up to 6x body length",
      "land on feet (righting reflex)",
      "see in low light (6x better than humans)",
      "hear ultrasonic frequencies",
      "retract claws",
      "run up to 30 mph in short bursts"
    ],
    
    "limitations": [
      "cannot taste sweetness",
      "obligate carnivore (cannot digest plant matter well)",
      "cannot see in complete darkness",
      "poor long-distance runner"
    ]
  }
}
```

## 6.9 FUNCTION Fields

```json
{
  "function": {
    "primary_purpose": {
      "natural": "small predator in ecosystem, controls rodent populations",
      "human_context": "companion animal, pest control"
    },
    
    "secondary_purposes": [
      "emotional support",
      "internet entertainment",
      "cultural/religious symbol (historical)"
    ],
    
    "serves": [
      {"beneficiary": "self", "how": "survival, reproduction"},
      {"beneficiary": "humans", "how": "companionship, pest control"},
      {"beneficiary": "ecosystem", "how": "population control of small animals"}
    ],
    
    "role_in_system": {
      "system": "domestic household",
      "role": "pet/companion",
      "interactions": ["fed by humans", "provides companionship", "hunts pests"]
    }
  }
}
```

## 6.10 TEMPORAL Fields

```json
{
  "temporal": {
    "lifecycle": [
      {
        "stage": "kitten",
        "duration": {"value": 6, "unit": "months"},
        "characteristics": ["dependent on mother", "rapid growth", "learning to hunt", "socialization window"],
        "transitions_to": "juvenile",
        "transition_trigger": "weaning complete, size threshold"
      },
      {
        "stage": "juvenile",
        "duration": {"value": 6, "unit": "months"},
        "characteristics": ["independent", "playful", "reaching sexual maturity"],
        "transitions_to": "adult",
        "transition_trigger": "sexual maturity reached"
      },
      {
        "stage": "adult",
        "duration": {"value": 10, "unit": "years", "range": "8-15 years"},
        "characteristics": ["fully grown", "capable of reproduction", "stable behavior"],
        "transitions_to": "senior",
        "transition_trigger": "age ~10-12 years, declining function"
      },
      {
        "stage": "senior",
        "duration": {"value": 5, "unit": "years", "range": "3-8 years"},
        "characteristics": ["reduced activity", "possible health issues", "sleeping more"],
        "transitions_to": "death",
        "transition_trigger": "organ failure, disease, age"
      }
    ],
    
    "states": [
      {"state": "awake_alert", "typical_duration": "hours"},
      {"state": "awake_relaxed", "typical_duration": "hours"},
      {"state": "sleeping_light", "typical_duration": "15-30 min cycles"},
      {"state": "sleeping_deep", "typical_duration": "5-10 min periods"},
      {"state": "hunting_mode", "typical_duration": "minutes"},
      {"state": "frightened", "typical_duration": "minutes to hours"}
    ],
    
    "lifespan": {
      "typical": {"value": 15, "unit": "years"},
      "range": {"min": 10, "max": 20, "unit": "years"},
      "factors": ["indoor vs outdoor", "breed", "health care", "genetics"]
    },
    
    "rate_of_change": "slow (stable adult form for years)"
  }
}
```

## 6.11 CAUSAL Fields

```json
{
  "causal": {
    "requires": [
      {
        "what": "food (protein-based)",
        "ref": "food.meat",
        "necessity": "required",
        "frequency": "1-2 times daily",
        "consequence_if_missing": "starvation, death"
      },
      {
        "what": "water",
        "ref": "substance.water",
        "necessity": "required",
        "frequency": "daily",
        "consequence_if_missing": "dehydration, death"
      },
      {
        "what": "shelter",
        "necessity": "required for survival",
        "consequence_if_missing": "exposure, reduced lifespan"
      }
    ],
    
    "produces": [
      {
        "what": "waste (feces, urine)",
        "frequency": "daily",
        "reliability": "always"
      },
      {
        "what": "hairballs",
        "frequency": "periodic",
        "reliability": "usually"
      },
      {
        "what": "offspring",
        "conditions": "mating, female not spayed",
        "quantity": "3-5 per litter",
        "frequency": "up to 3 litters per year"
      }
    ],
    
    "causes": [
      {
        "effect": "reduction in local rodent population",
        "mechanism": "predation",
        "strength": "moderate to strong"
      },
      {
        "effect": "reduction in local bird population",
        "mechanism": "predation",
        "strength": "moderate (outdoor cats)"
      },
      {
        "effect": "human allergic reactions",
        "mechanism": "Fel d 1 protein in saliva/skin",
        "strength": "variable by human"
      }
    ],
    
    "caused_by": [
      {
        "cause": "evolution of small feline predators",
        "mechanism": "natural selection"
      },
      {
        "cause": "human domestication",
        "mechanism": "selective breeding, mutualism",
        "timeframe": "~10,000 years ago"
      }
    ],
    
    "prevents": [
      {
        "what": "rodent infestation",
        "mechanism": "predation + deterrence (scent)",
        "effectiveness": "moderate to high"
      }
    ]
  }
}
```

## 6.12 RELATIONAL Fields

```json
{
  "relational": {
    "relationships": [
      {
        "type": "PREYS_ON",
        "target_ref": "20.1022",
        "target_name": "Mouse",
        "strength": "strong",
        "context": "natural behavior, especially outdoor cats"
      },
      {
        "type": "PREYS_ON",
        "target_ref": "20.1087",
        "target_name": "Bird",
        "strength": "moderate",
        "context": "outdoor cats"
      },
      {
        "type": "PREYED_BY",
        "target_ref": "20.1055",
        "target_name": "Coyote",
        "strength": "moderate",
        "context": "outdoor cats in relevant regions"
      },
      {
        "type": "DOMESTICATED_BY",
        "target_ref": "20.0001",
        "target_name": "Human",
        "strength": "strong",
        "context": "~10,000 year relationship"
      },
      {
        "type": "COMPETES_WITH",
        "target_ref": "20.1005",
        "target_name": "Dog",
        "strength": "low",
        "context": "for human attention in households"
      }
    ],
    
    "contrasts_with": [
      {
        "concept_ref": "20.1005",
        "concept_name": "Dog",
        "dimension": "sociability",
        "contrast": "cats more independent, dogs more pack-oriented"
      }
    ],
    
    "similar_to": [
      {
        "concept_ref": "20.1055",
        "concept_name": "Lion",
        "similarity": "body plan, hunting behavior, feline family",
        "difference": "size, social structure"
      }
    ],
    
    "part_of": [
      {
        "whole_ref": "cat.family.felidae",
        "whole_name": "Felidae (cat family)",
        "relationship": "taxonomic member"
      },
      {
        "whole_ref": "ecosystem.domestic",
        "whole_name": "Domestic ecosystem",
        "relationship": "participant"
      }
    ],
    
    "contains": [
      {
        "part_ref": "20.1004.skeleton",
        "part_name": "Cat Skeleton"
      },
      {
        "part_ref": "20.1004.organs",
        "part_name": "Cat Organs"
      }
    ]
  }
}
```

## 6.13 CONTEXTUAL Fields

```json
{
  "contextual": {
    "typical_location": {
      "places": ["homes", "apartments", "farms", "streets (feral)"],
      "environments": ["urban", "suburban", "rural"],
      "specifics": "anywhere humans live, plus feral populations worldwide"
    },
    
    "conditions": {
      "required": {
        "temperature": {"min": -20, "max": 45, "unit": "°C", "notes": "with shelter"},
        "food_availability": "regular protein source"
      },
      "optimal": {
        "temperature": {"min": 18, "max": 28, "unit": "°C"},
        "environment": "safe, warm, with hiding spots and vertical space"
      },
      "fatal": {
        "temperature": {"below": -30, "above": 50, "unit": "°C", "notes": "without shelter"},
        "other": ["drowning", "predation", "starvation", "disease"]
      }
    },
    
    "distribution": {
      "geographic": "worldwide except Antarctica",
      "population": "~600 million domestic, ~100 million feral",
      "density": "highest in urban areas with humans"
    },
    
    "era": {
      "origin": "~10,000 years ago (domestication)",
      "peak": "present (most popular pet globally)"
    },
    
    "cultural_context": {
      "western": "beloved pet, internet icon",
      "ancient_egypt": "sacred, associated with goddess Bastet",
      "medieval_europe": "associated with witchcraft (negative)",
      "japan": "good luck symbol (maneki-neko)"
    }
  }
}
```

## 6.14 VARIANCE Fields

```json
{
  "variance": {
    "dimensions": {
      "size": {
        "variance": "±30%",
        "range": {"min": "2kg", "max": "10kg"},
        "factors": ["breed", "diet", "health"]
      },
      "color": {
        "variance": "high",
        "options": ["solid", "tabby", "bicolor", "tricolor", "pointed"],
        "genetic_basis": "multiple genes"
      },
      "fur_length": {
        "variance": "moderate",
        "options": ["hairless", "short", "medium", "long"],
        "genetic_basis": "breed-specific"
      },
      "temperament": {
        "variance": "moderate",
        "range": ["very shy", "shy", "moderate", "friendly", "very friendly"],
        "factors": ["breed", "socialization", "individual"]
      }
    },
    
    "what_stays_constant": [
      "basic body plan (quadruped, head, tail)",
      "carnivore diet requirement",
      "retractable claws",
      "hunting instincts",
      "general size range"
    ]
  },
  
  "variants": [
    {
      "name": "Persian",
      "ref": "20.1004.persian",
      "inherits_from": "20.1004",
      "overrides": {
        "structure_spatial.parts.head.shape": "flat (brachycephalic)",
        "surface.visual.texture_appearance": "long fluffy fur",
        "properties.intrinsic.activity_level": "low"
      }
    },
    {
      "name": "Siamese",
      "ref": "20.1004.siamese",
      "inherits_from": "20.1004",
      "overrides": {
        "surface.visual.colors.pattern": "pointed",
        "surface.auditory.sounds_produced.meow.frequency": "more frequent, louder",
        "properties.intrinsic.sociability": "high"
      }
    }
  ],
  
  "instances": [
    {
      "name": "Whiskers",
      "ref": "20.1004.instance.001",
      "inherits_from": "20.1004",
      "specific_values": {
        "surface.visual.colors.common": ["orange", "white"],
        "properties.physical.mass.value": 5.2,
        "contextual.typical_location.places": ["123 Main St, Apartment 4B"],
        "relational.relationships": [{"type": "OWNED_BY", "target": "Shane"}]
      }
    }
  ]
}
```

## 6.15 REASONING_HOOKS Fields

```json
{
  "reasoning_hooks": {
    "for_appearance_query": {
      "retrieve": ["surface", "structure_spatial.overall", "structure_spatial.parts.*.shape"],
      "example_queries": ["What does a cat look like?", "Describe a cat"]
    },
    
    "for_movement_query": {
      "retrieve": ["structure_spatial.parts.legs", "behavior.capabilities", "properties.physical"],
      "example_queries": ["How fast can a cat run?", "Can cats climb?"]
    },
    
    "for_biology_query": {
      "retrieve": ["composition", "properties.physical", "temporal.lifecycle"],
      "example_queries": ["What are cats made of?", "How long do cats live?"]
    },
    
    "for_behavior_query": {
      "retrieve": ["behavior", "function", "relational"],
      "example_queries": ["What do cats do?", "Why do cats purr?"]
    },
    
    "for_care_query": {
      "retrieve": ["causal.requires", "contextual.conditions", "temporal.lifecycle"],
      "example_queries": ["How do I take care of a cat?", "What do cats need?"]
    },
    
    "for_comparison_query": {
      "retrieve": ["categorical", "relational.similar_to", "relational.contrasts_with", "surface"],
      "example_queries": ["How are cats different from dogs?", "What's similar to a cat?"]
    },
    
    "for_spatial_reasoning": {
      "retrieve": ["structure_spatial"],
      "example_queries": ["Can a cat fit through X?", "Where are a cat's ears?"]
    }
  }
}
```

---

# 7. The Type Categorization Engine

## 7.1 Purpose

When the system encounters something new, it needs to determine the type using explicit rules that any model can follow—not intuition.

## 7.2 The Decision Tree

```
NEW CONCEPT ENCOUNTERED
│
├─→ Q1: Can you point at it, touch it, or measure it physically?
│   │
│   ├── YES (Physical)
│   │   │
│   │   ├─→ Q2: Is it alive or was it once alive?
│   │   │   │
│   │   │   ├── YES → ORGANISM
│   │   │   │   │
│   │   │   │   └─→ Q2a: What kingdom?
│   │   │   │       ├── Makes own food (photosynthesis) → organism.plant
│   │   │   │       ├── Moves, eats others, has nucleus → organism.animal
│   │   │   │       │   └─→ Q2b: Further classification
│   │   │   │       │       ├── Warm-blooded + fur/hair → organism.animal.mammal
│   │   │   │       │       ├── Warm-blooded + feathers → organism.animal.bird
│   │   │   │       │       ├── Cold-blooded + scales + legs → organism.animal.reptile
│   │   │   │       │       ├── Cold-blooded + scales + no legs + water → organism.animal.fish
│   │   │   │       │       └── No backbone → organism.animal.invertebrate
│   │   │   │       ├── Absorbs nutrients, no movement → organism.fungi
│   │   │   │       └── Microscopic → organism.microorganism
│   │   │   │
│   │   │   └── NO (Not alive)
│   │   │       │
│   │   │       ├─→ Q3: Was it intentionally made by humans or agents?
│   │   │       │   │
│   │   │       │   ├── YES → ARTIFACT
│   │   │       │   │   │
│   │   │       │   │   └─→ Q4: Does it exist primarily in time (like music, film)?
│   │   │       │   │       ├── YES → artifact.temporal
│   │   │       │   │       │   └─→ Q4a: What medium?
│   │   │       │   │       │       ├── Audio → artifact.temporal.music
│   │   │       │   │       │       ├── Video → artifact.temporal.video
│   │   │       │   │       │       └── Live → artifact.temporal.performance
│   │   │       │   │       │
│   │   │       │   │       └── NO → artifact.physical
│   │   │       │   │           └─→ Q4b: What kind?
│   │   │       │   │               ├── Used to accomplish tasks → artifact.physical.tool
│   │   │       │   │               ├── Transports people/things → artifact.physical.vehicle
│   │   │       │   │               ├── Shelters/encloses space → artifact.physical.building
│   │   │       │   │               └── ... (other subtypes)
│   │   │       │   │
│   │   │       │   └── NO (Natural, non-living)
│   │   │       │       │
│   │   │       │       └─→ Q5: Is it a location or place?
│   │   │       │           ├── YES → place
│   │   │       │           │   └─→ Q5a: Natural or constructed?
│   │   │       │           │       ├── Natural → place.natural
│   │   │       │           │       └── Constructed → place.constructed
│   │   │       │           │
│   │   │       │           └── NO → natural_object
│   │   │       │               └─→ Q5b: What domain?
│   │   │       │                   ├── Rock/mineral/land → natural_object.geological
│   │   │       │                   ├── Star/planet/space → natural_object.astronomical
│   │   │       │                   └── Weather-related → natural_object.atmospheric
│   │
│   └── NO (Non-physical)
│       │
│       ├─→ Q6: Does it happen or occur? (Has a start and end in time)
│       │   │
│       │   ├── YES (Event-like)
│       │   │   │
│       │   │   └─→ Q7: Is it a repeatable template/instructions, or a unique occurrence?
│       │   │       │
│       │   │       ├── REPEATABLE → process
│       │   │       │   └─→ Q7a: What kind?
│       │   │       │       ├── Step-by-step instructions → process.instructional
│       │   │       │       ├── Natural biological process → process.natural
│       │   │       │       └── Social procedure → process.social
│       │   │       │
│       │   │       └── UNIQUE OCCURRENCE → event
│       │   │           └─→ Q7b: Duration?
│       │   │               ├── Instantaneous → event.moment
│       │   │               ├── Bounded period → event.period
│       │   │               └── Ongoing, no clear end → event.continuous
│       │   │
│       │   └── SORT OF (ongoing observable occurrence)
│       │       └─→ Is it a recurring natural phenomenon?
│       │           └── YES → phenomenon
│       │               └─→ Q: What domain?
│       │                   ├── Physics-based → phenomenon.physical
│       │                   ├── Weather → phenomenon.weather
│       │                   └── Social → phenomenon.social
│       │
│       └── NO (Doesn't "happen" - it just exists abstractly)
│           │
│           ├─→ Q8: Does it refer to something else? (Changes based on context)
│           │   └── YES → reference
│           │       └─→ What kind?
│           │           ├── Time-based (tomorrow, last year) → reference.temporal
│           │           ├── Space-based (here, there) → reference.spatial
│           │           └── Role-based (the president) → reference.possessive
│           │
│           ├─→ Q9: Is it defined by what's NOT there? (Void, absence, lack)
│           │   └── YES → absence
│           │       └─→ What kind?
│           │           ├── Spatial void → absence.spatial
│           │           ├── Temporal gap → absence.temporal
│           │           └── Conceptual lack → absence.conceptual
│           │
│           ├─→ Q10: Is it a group of agents with structure and shared purpose?
│           │   └── YES → organization
│           │       └─→ What kind?
│           │           ├── For-profit entity → organization.corporate
│           │           ├── Government body → organization.governmental
│           │           ├── Social group → organization.social
│           │           └── Religious group → organization.religious
│           │
│           ├─→ Q11: Does it involve rules and interacting agents?
│           │   └── YES → system
│           │       └─→ What domain?
│           │           ├── Power/government → system.governance
│           │           ├── Game/competition → system.interactive
│           │           ├── Communication → system.language
│           │           └── Technical → system.technical
│           │
│           ├─→ Q12: Is it a quality or attribute that attaches to other things?
│           │   └── YES → property
│           │       └─→ What kind?
│           │           ├── Perceived by senses → property.sensory
│           │           ├── Exists only between things → property.relational
│           │           └── Inherent to one thing → property.intrinsic
│           │
│           ├─→ Q13: Is it an internal mental experience or feeling?
│           │   └── YES → experience
│           │       └─→ What kind?
│           │           ├── Complex feeling with cognitive component → experience.emotion
│           │           ├── Simple body signal → experience.sensation
│           │           └── Mental state/process → experience.cognitive
│           │
│           ├─→ Q14: Is it a repeated behavior pattern attached to an agent?
│           │   └── YES → pattern
│           │       └─→ What kind?
│           │           ├── Personal behavior → pattern.habit
│           │           ├── Cultural behavior → pattern.tradition
│           │           └── Compulsive behavior → pattern.addiction
│           │
│           ├─→ Q15: Is it a capacity or skill that an agent can have?
│           │   └── YES → ability
│           │       └─→ What domain?
│           │           ├── Body-based → ability.physical
│           │           ├── Mind-based → ability.cognitive
│           │           └── Interaction-based → ability.social
│           │
│           ├─→ Q16: Is it a temporary condition of something?
│           │   └── YES → state
│           │       └─→ What domain?
│           │           ├── Body condition → state.physical
│           │           ├── Emotional condition → state.emotional
│           │           └── Social condition → state.social
│           │
│           ├─→ Q17: Is it a universal rule governing how things behave?
│           │   └── YES → law
│           │       └─→ What domain?
│           │           ├── Physics → law.physical
│           │           ├── Biology → law.biological
│           │           └── Economics → law.economic
│           │
│           ├─→ Q18: Is it a grouping or classification of other things?
│           │   └── YES → category
│           │       └─→ What kind?
│           │           ├── Scientific classification → category.taxonomic
│           │           └── General classification → category.classification
│           │
│           ├─→ Q19: Is it the connection or relationship itself (not the things connected)?
│           │   └── YES → relation
│           │       └─→ What kind?
│           │           ├── Cause-effect link → relation.causal
│           │           ├── Part-whole link → relation.compositional
│           │           └── General association → relation.associative
│           │
│           ├─→ Q20: Is it something that could exist but doesn't yet?
│           │   └── YES → potential
│           │       └─→ What kind?
│           │           ├── General possibility → potential.possibility
│           │           ├── Negative possibility → potential.risk
│           │           └── Positive possibility → potential.opportunity
│           │
│           ├─→ Q21: Is it a container holding other concepts (dream, story, scenario)?
│           │   └── YES → composite
│           │       └─→ What kind?
│           │           ├── Dream → composite.dream
│           │           ├── Narrative → composite.story
│           │           └── Hypothetical → composite.scenario
│           │
│           ├─→ Q22: Is it a speech act (does something when spoken)?
│           │   └── YES → linguistic
│           │       └─→ What kind?
│           │           ├── States something → linguistic.speech_act.assertive
│           │           ├── Asks/commands → linguistic.speech_act.directive
│           │           └── Commits to something → linguistic.speech_act.commissive
│           │
│           └─→ Q23: Is it defined purely by formal rules (math, logic)?
│               ├── YES → abstraction.formal
│               └── NO → abstraction.conceptual
```

## 7.3 Type to Required Categories Mapping

```python
TYPE_TO_CATEGORIES = {
  
  "organism": {
    "required": [
      "definition", "type", "grounding",
      "categorical",
      "composition",
      "structure_spatial",
      "surface",
      "properties",
      "behavior",
      "temporal",
      "causal",
      "relational",
      "contextual"
    ],
    "recommended": [
      "function",
      "variance"
    ]
  },
  
  "organism.animal.mammal": {
    "inherits": "organism",
    "additional_required": [],
    "additional_recommended": []
  },
  
  "artifact.physical": {
    "required": [
      "definition", "type", "grounding",
      "categorical",
      "composition",
      "structure_spatial",
      "surface",
      "function",
      "properties"
    ],
    "recommended": [
      "behavior",
      "causal",
      "contextual"
    ]
  },
  
  "artifact.temporal": {
    "required": [
      "definition", "type", "grounding",
      "categorical",
      "composition",
      "structure_temporal",
      "surface",
      "function"
    ],
    "recommended": [
      "contextual",
      "relational"
    ]
  },
  
  "event": {
    "required": [
      "definition", "type", "grounding",
      "categorical",
      "temporal",
      "causal",
      "participants"
    ],
    "recommended": [
      "contextual",
      "relational",
      "components"
    ]
  },
  
  "process": {
    "required": [
      "definition", "type", "grounding",
      "categorical",
      "structure_temporal",
      "steps",
      "inputs",
      "outputs"
    ],
    "recommended": [
      "causal",
      "constraints"
    ]
  },
  
  "system.governance": {
    "required": [
      "definition", "type", "grounding",
      "categorical",
      "components",
      "structure_hierarchical",
      "function"
    ],
    "recommended": [
      "causal",
      "temporal",
      "contrasts_with"
    ]
  },
  
  "system.interactive": {
    "required": [
      "definition", "type", "grounding",
      "categorical",
      "participants",
      "rules",
      "states",
      "win_condition"
    ],
    "recommended": [
      "components"
    ]
  },
  
  "experience.emotion": {
    "required": [
      "definition", "type", "grounding",
      "categorical",
      "manifestation",
      "causal"
    ],
    "recommended": [
      "temporal",
      "variants",
      "contrasts_with"
    ]
  },
  
  "experience.sensation": {
    "required": [
      "definition", "type", "grounding",
      "categorical",
      "source",
      "location",
      "manifestation"
    ],
    "recommended": [
      "function",
      "intensity"
    ]
  },
  
  "property.sensory": {
    "required": [
      "definition", "type", "grounding",
      "categorical",
      "physical_definition",
      "relational"
    ],
    "recommended": [
      "associations",
      "requires"
    ]
  },
  
  "property.relational": {
    "required": [
      "definition", "type", "grounding",
      "categorical",
      "between",
      "value_type"
    ],
    "recommended": [
      "context",
      "varies_by"
    ]
  },
  
  "abstraction.formal": {
    "required": [
      "definition", "type", "grounding",
      "categorical",
      "structure_definitional",
      "representations"
    ],
    "recommended": [
      "associations"
    ]
  },
  
  "abstraction.conceptual": {
    "required": [
      "definition", "type", "grounding",
      "categorical",
      "components",
      "relational"
    ],
    "recommended": [
      "associations",
      "contrasts_with"
    ]
  },
  
  "organization": {
    "required": [
      "definition", "type", "grounding",
      "categorical",
      "members",
      "structure_hierarchical",
      "function"
    ],
    "recommended": [
      "rules",
      "assets",
      "contextual"
    ]
  },
  
  "pattern": {
    "required": [
      "definition", "type", "grounding",
      "categorical",
      "attached_to",
      "trigger",
      "behavior"
    ],
    "recommended": [
      "frequency",
      "strength",
      "causal"
    ]
  },
  
  "ability": {
    "required": [
      "definition", "type", "grounding",
      "categorical",
      "attached_to",
      "enables"
    ],
    "recommended": [
      "requires",
      "levels",
      "acquisition"
    ]
  },
  
  "state": {
    "required": [
      "definition", "type", "grounding",
      "categorical",
      "of_what",
      "conditions",
      "manifestation"
    ],
    "recommended": [
      "transitions_to",
      "duration"
    ]
  },
  
  "law": {
    "required": [
      "definition", "type", "grounding",
      "categorical",
      "domain",
      "formula_or_description",
      "effects"
    ],
    "recommended": [
      "requires",
      "exceptions"
    ]
  },
  
  "absence": {
    "required": [
      "definition", "type", "grounding",
      "categorical",
      "defined_by",
      "structure_spatial"
    ],
    "recommended": [
      "function"
    ]
  },
  
  "reference": {
    "required": [
      "definition", "type", "grounding",
      "categorical",
      "relative_to",
      "resolves_to"
    ],
    "recommended": [
      "function"
    ]
  },
  
  "potential": {
    "required": [
      "definition", "type", "grounding",
      "categorical",
      "would_be_type",
      "conditions",
      "probability"
    ],
    "recommended": [
      "blocks",
      "enables"
    ]
  },
  
  "composite": {
    "required": [
      "definition", "type", "grounding",
      "categorical",
      "contains",
      "frame"
    ],
    "recommended": [
      "internal_structure",
      "purpose"
    ]
  },
  
  "category": {
    "required": [
      "definition", "type", "grounding",
      "categorical",
      "members",
      "criteria"
    ],
    "recommended": [
      "boundaries",
      "hierarchy"
    ]
  },
  
  "relation": {
    "required": [
      "definition", "type", "grounding",
      "categorical",
      "between",
      "direction",
      "properties"
    ],
    "recommended": [
      "inverse"
    ]
  },
  
  "linguistic": {
    "required": [
      "definition", "type", "grounding",
      "categorical",
      "structure",
      "function",
      "requires"
    ],
    "recommended": [
      "expects"
    ]
  },
  
  "phenomenon": {
    "required": [
      "definition", "type", "grounding",
      "categorical",
      "manifestation",
      "conditions",
      "causal"
    ],
    "recommended": [
      "measurable_properties"
    ]
  }
}
```

## 7.4 Handling Uncertainty

```python
UNCERTAINTY_PROTOCOL = {
  
  "stuck_between_two_types": {
    "action": "Assign BOTH types as array",
    "flag": "needs_human_review: true",
    "fill_categories": "Union of both types' required categories",
    "example": {
      "concept": "Bitcoin",
      "type": ["system.economic", "artifact.digital"],
      "flags": ["hybrid", "needs_human_review"]
    }
  },
  
  "no_type_fits": {
    "action": "Assign 'unknown'",
    "fill_categories": ["categorical", "definition", "relational", "grounding"],
    "flag": "needs_new_type: true"
  },
  
  "question_ambiguous": {
    "action": "Log which question was unclear, make best guess",
    "flag": "categorization_uncertain: true",
    "record": "uncertain_at: Q7"
  },
  
  "confidence_scoring": {
    "method": "Each question answered confidently: +0.1, Each uncertain: -0.1",
    "use": "Determines review priority"
  }
}
```

## 7.5 The Categorization Algorithm

```python
def categorize_new_concept(concept_description, concept_name):
    """
    Determine the type of a new concept using the decision tree.
    Any model can follow this—it's explicit yes/no questions.
    """
    
    type_path = []
    confidence = 1.0
    flags = []
    uncertain_questions = []
    
    # Q1: Physical?
    physical = ask_question(
        "Can you point at it, touch it, or measure it physically?",
        concept_description
    )
    
    if physical == YES:
        # Q2: Alive?
        alive = ask_question(
            "Is it alive or was it once alive?",
            concept_description
        )
        
        if alive == YES:
            type_path = ["organism"]
            kingdom = determine_kingdom(concept_description)
            type_path.append(kingdom)
            
            if kingdom == "animal":
                animal_class = determine_animal_class(concept_description)
                type_path.append(animal_class)
        
        else:
            # Q3: Made by agents?
            made = ask_question(
                "Was it intentionally made by humans or intelligent agents?",
                concept_description
            )
            
            if made == YES:
                # Q4: Temporal?
                temporal = ask_question(
                    "Does it exist primarily in time, like music or film?",
                    concept_description
                )
                
                if temporal == YES:
                    type_path = ["artifact", "temporal"]
                    medium = determine_medium(concept_description)
                    type_path.append(medium)
                else:
                    type_path = ["artifact", "physical"]
                    artifact_kind = determine_artifact_kind(concept_description)
                    type_path.append(artifact_kind)
            
            else:
                # Q5: Place?
                place = ask_question(
                    "Is it a location or place?",
                    concept_description
                )
                
                if place == YES:
                    type_path = ["place"]
                    place_kind = determine_place_kind(concept_description)
                    type_path.append(place_kind)
                else:
                    type_path = ["natural_object"]
                    natural_kind = determine_natural_kind(concept_description)
                    type_path.append(natural_kind)
    
    else:
        # Non-physical: Run through the decision tree
        type_path = categorize_non_physical(concept_description)
    
    # Calculate final type string
    final_type = ".".join(type_path)
    
    # Get required categories for this type
    required_categories = get_required_categories(final_type)
    recommended_categories = get_recommended_categories(final_type)
    
    return {
        "name": concept_name,
        "type": final_type,
        "required_categories": required_categories,
        "recommended_categories": recommended_categories,
        "confidence": confidence,
        "flags": flags,
        "uncertain_questions": uncertain_questions
    }


def categorize_non_physical(description):
    """
    Handle the non-physical branch of categorization.
    """
    
    # Q6: Event-like?
    happens = ask_question(
        "Does it happen or occur? Does it have a start and end in time?",
        description
    )
    
    if happens == YES:
        # Q7: Repeatable?
        repeatable = ask_question(
            "Is it a repeatable template or instructions, rather than a unique occurrence?",
            description
        )
        
        if repeatable == YES:
            return ["process", determine_process_kind(description)]
        else:
            return ["event", determine_event_kind(description)]
    
    if happens == SORT_OF:
        return ["phenomenon", determine_phenomenon_kind(description)]
    
    # Run through special case checks
    special_checks = [
        ("Does it refer to something else, changing based on context?", ["reference"]),
        ("Is it defined by what's NOT there (void, absence, lack)?", ["absence"]),
        ("Is it a group of agents with structure and shared purpose?", ["organization"]),
        ("Does it involve rules and interacting agents?", ["system"]),
        ("Is it a quality or attribute that attaches to other things?", ["property"]),
        ("Is it an internal mental experience or feeling?", ["experience"]),
        ("Is it a repeated behavior pattern attached to an agent?", ["pattern"]),
        ("Is it a capacity or skill that an agent can have?", ["ability"]),
        ("Is it a temporary condition of something?", ["state"]),
        ("Is it a universal rule governing how things behave?", ["law"]),
        ("Is it a grouping or classification of other things?", ["category"]),
        ("Is it the connection or relationship itself?", ["relation"]),
        ("Is it something that could exist but doesn't yet?", ["potential"]),
        ("Is it a container holding other concepts?", ["composite"]),
        ("Is it a speech act that does something when spoken?", ["linguistic"]),
    ]
    
    for question, type_path in special_checks:
        if ask_question(question, description) == YES:
            # Determine subtype
            subtype = determine_subtype(type_path[0], description)
            return type_path + [subtype] if subtype else type_path
    
    # Default: abstraction
    formal = ask_question(
        "Is it defined purely by formal rules (math, logic)?",
        description
    )
    
    if formal == YES:
        return ["abstraction", "formal"]
    else:
        return ["abstraction", "conceptual"]
```

---

# 8. The Data Filling System

## 8.1 Purpose

Once the type is determined, the system needs to fill in the data for each required category. This uses explicit questions that any model can follow.

## 8.2 The Question Protocol

```python
QUESTION_PROTOCOL = {

    "definition": [
        "In one sentence, what is {concept}?",
        "How would you explain {concept} to someone who has never heard of it?"
    ],
    
    "categorical": [
        "What is {concept} a type of?",
        "What is {parent} a type of?",  # Repeat until reaching root
        "What other things are also {parent}? (siblings)",
        "What makes {concept} different from its siblings?"
    ],
    
    "composition": [
        "What is {concept} made of? List the main components.",
        "For {component}: What is it made of?",  # Repeat until base layer
        "How do the components fit together to form {concept}?"
    ],
    
    "structure_spatial": [
        "What is the center or main body of {concept}?",
        "What parts does {concept} have?",
        "For {part}:",
        "  - Where is it relative to the center? (position)",
        "  - What shape is it?",
        "  - What size is it?",
        "  - How is it connected to the rest?",
        "  - Can it move? If so, how?",
        "What is the overall shape of {concept}?",
        "What is the overall size of {concept}?",
        "Does {concept} have symmetry? What kind?"
    ],
    
    "structure_temporal": [
        "When does {concept} start?",
        "What are the phases or segments of {concept}?",
        "For {phase}:",
        "  - When does it start (relative to the beginning)?",
        "  - How long does it last?",
        "  - What happens during this phase?",
        "  - What comes before it?",
        "  - What comes after it?",
        "How long is {concept} in total?",
        "Is there a repeating pattern?"
    ],
    
    "structure_hierarchical": [
        "What is at the top of {concept}'s structure?",
        "What levels or layers exist?",
        "For {level}:",
        "  - Who or what is at this level?",
        "  - What power or authority do they have?",
        "  - Who do they report to?",
        "  - Who reports to them?",
        "How does power flow through the structure?",
        "How does information flow?",
        "Are there checks and balances between levels?"
    ],
    
    "structure_definitional": [
        "What are the fundamental axioms or assumptions that define {concept}?",
        "What properties follow from these axioms?",
        "What rules govern how {concept} behaves?",
        "What constraints must always be true for {concept}?"
    ],
    
    "surface": [
        "What does {concept} look like? (colors, shape, distinctive features)",
        "What would you notice first about {concept}?",
        "What sounds does {concept} make or produce?",
        "What does {concept} feel like to touch?",
        "Does {concept} have a smell? What kind?",
        "How big does {concept} seem? (tiny/small/medium/large/huge)",
        "In one sentence, what's the overall impression of {concept}?"
    ],
    
    "manifestation": [
        "What physical signs indicate {concept}? (body changes)",
        "What behavioral signs indicate {concept}? (actions)",
        "What cognitive signs indicate {concept}? (thought patterns)",
        "What does {concept} feel like from the inside? (subjective quality)"
    ],
    
    "properties": [
        "What can you measure about {concept}? (mass, length, temperature, etc.)",
        "For {measurement}: What is the typical value? What is the range?",
        "What inherent qualities does {concept} have?",
        "What value, importance, or danger do humans assign to {concept}?",
        "What about {concept} changes over time?"
    ],
    
    "behavior": [
        "What does {concept} do on its own? (actions)",
        "For {action}: How often? Under what conditions?",
        "How does {concept} react to different situations?",
        "What is {concept} capable of doing? (capabilities)",
        "What can {concept} NOT do? (limitations)"
    ],
    
    "function": [
        "What is {concept} FOR? What is its main purpose?",
        "Does {concept} have other uses or purposes?",
        "Who or what benefits from {concept}?",
        "What larger system is {concept} part of? What role does it play?"
    ],
    
    "temporal": [
        "Does {concept} go through stages? What are they?",
        "For {stage}:",
        "  - How long does it last?",
        "  - What characterizes this stage?",
        "  - What triggers the transition to the next stage?",
        "What temporary states can {concept} be in?",
        "How long does {concept} exist in total? (lifespan)"
    ],
    
    "causal": [
        "What does {concept} need to exist or function? (requirements)",
        "What does {concept} produce or create? (outputs)",
        "What effects does {concept} cause?",
        "What causes {concept}?",
        "What does {concept} prevent or block?"
    ],
    
    "relational": [
        "What other concepts is {concept} related to?",
        "For {related_concept}:",
        "  - What kind of relationship is it?",
        "  - How strong is the relationship?",
        "  - In what context does the relationship apply?",
        "What is {concept} the opposite of?",
        "What is {concept} similar to?",
        "What larger thing is {concept} part of?",
        "What smaller things does {concept} contain?"
    ],
    
    "contextual": [
        "Where is {concept} typically found? (places, environments)",
        "What conditions does {concept} need to exist?",
        "What conditions are optimal for {concept}?",
        "What conditions would destroy or kill {concept}?",
        "Where in the world does {concept} exist?",
        "When in history did/does {concept} exist?",
        "What cultures associate with {concept}?"
    ],
    
    "grounding": [
        "How do we know {concept} exists?",
        "What evidence supports the existence of {concept}?",
        "Can {concept} be directly observed, or is it inferred from something else?",
        "If inferred, what is the chain of reasoning from observation to {concept}?",
        "How confident are we that {concept} is real? (0-100%)",
        "What is the weakest point in our knowledge of {concept}?"
    ],
    
    "variance": [
        "How much can {concept} vary and still be {concept}?",
        "What aspects of {concept} vary the most?",
        "What aspects of {concept} stay constant?",
        "Are there recognized subtypes or variants of {concept}?",
        "Can you give a specific example/instance of {concept}?"
    ],
    
    # Type-specific questions
    
    "participants": [  # For events, systems
        "Who or what participates in {concept}?",
        "What roles do the participants play?",
        "Are there sides or factions? What are they?"
    ],
    
    "rules": [  # For systems, games
        "What rules govern {concept}?",
        "What is allowed?",
        "What is forbidden?",
        "What happens if rules are broken?"
    ],
    
    "steps": [  # For processes
        "What are the steps in {concept}?",
        "What order do they happen in?",
        "Which steps depend on other steps?",
        "Can steps be skipped or reordered?"
    ],
    
    "inputs_outputs": [  # For processes
        "What inputs does {concept} require?",
        "What outputs does {concept} produce?",
        "What transforms the inputs into outputs?"
    ],
    
    "trigger": [  # For patterns, sensations
        "What triggers {concept}?",
        "How reliably does the trigger cause {concept}?"
    ],
    
    "representations": [  # For abstractions
        "How is {concept} represented? (symbols, words, forms)",
        "What are the different ways to express {concept}?"
    ],
    
    "associations": [  # For properties, concepts
        "What natural things are associated with {concept}?",
        "What cultural associations does {concept} have?",
        "What emotional associations does {concept} have?"
    ],
    
    "members_criteria": [  # For categories
        "What things are members of {concept}?",
        "What criteria must something meet to be a member?",
        "What are the boundaries of {concept}?"
    ]
}
```

## 8.3 The Data Filling Algorithm

```python
def fill_concept_data(concept_name, initial_description):
    """
    Fill all required data for a new concept.
    """
    
    # Step 1: Categorize to determine type
    categorization = categorize_new_concept(initial_description, concept_name)
    
    # Initialize concept structure
    concept = {
        "id": generate_id(categorization["type"]),
        "name": concept_name,
        "type": categorization["type"],
        "aliases": [],
        "definition": None,
        "grounding": None,
        "flags": categorization["flags"],
        # ... initialize all category containers
    }
    
    # Step 2: Fill required categories
    for category in categorization["required_categories"]:
        questions = QUESTION_PROTOCOL.get(category, [])
        
        for question_template in questions:
            # Format question with concept name and context
            question = format_question(question_template, concept)
            
            # Ask the question
            answer = ask_and_parse(question, concept, initial_description)
            
            # Validate the answer
            validation = validate_answer(answer, category, concept)
            
            if validation["valid"]:
                store_answer(concept, category, answer)
            else:
                # Store anyway but flag for review
                store_answer(concept, category, answer)
                concept["flags"].append({
                    "type": "validation_warning",
                    "category": category,
                    "issue": validation["issue"]
                })
        
        # Handle recursive filling (composition chains, categorical chains)
        if category_needs_recursion(category):
            fill_recursive(

!!!Max chat context reach!!!


concept, category)
    
    # Step 3: Fill recommended categories (if resources allow)
    for category in categorization["recommended_categories"]:
        # Same process as required, but failures don't flag as errors
        try:
            fill_category(concept, category)
        except InsufficientDataError:
            pass  # Recommended, not required
    
    # Step 4: Validate completeness
    completeness = calculate_completeness(concept, categorization)
    concept["completeness"] = completeness
    
    if not completeness["required_complete"]:
        concept["flags"].append({
            "type": "incomplete",
            "missing": completeness["missing_required"]
        })
    
    # Step 5: Validate data quality
    quality_issues = validate_all_fields(concept)
    
    if quality_issues:
        concept["flags"].append({
            "type": "quality_issues",
            "issues": quality_issues
        })
    
    # Step 6: Calculate overall confidence
    concept["confidence"] = calculate_overall_confidence(concept, categorization, completeness)
    
    # Step 7: Generate reasoning hooks
    concept["reasoning_hooks"] = generate_reasoning_hooks(concept)
    
    return concept


def fill_recursive(concept, category):
    """
    Handle categories that need recursive depth (composition, categorical).
    """
    
    if category == "composition":
        # Fill composition levels until hitting base layer
        current_level = 0
        current_components = concept["composition"]["levels"][0]["components"]
        base_layer = get_base_layer_for_domain(concept["type"])
        
        while not at_base_layer(current_components, base_layer):
            current_level += 1
            next_level_components = []
            
            for component in current_components:
                sub_components = ask_and_parse(
                    f"What is {component['name']} made of?",
                    concept
                )
                next_level_components.extend(sub_components)
            
            concept["composition"]["levels"].append({
                "depth": current_level,
                "components": next_level_components
            })
            
            current_components = next_level_components
        
        concept["composition"]["base_layer"] = base_layer
    
    elif category == "categorical":
        # Fill categorical chain until hitting root
        chain = [concept["name"]]
        current = concept["name"]
        
        while not is_root_type(current):
            parent = ask_and_parse(
                f"What is {current} a type of?",
                concept
            )
            chain.append(parent)
            current = parent
        
        concept["categorical"]["chain"] = chain
```

## 8.4 Completeness Checking

```python
MINIMUM_REQUIREMENTS = {
    "organism": {
        "required_fields": [
            "definition",
            "categorical.chain",
            "composition.levels[0].components[1+]",  # At least one level with components
            "structure_spatial.parts[3+]",           # At least 3 parts
            "surface.visual",
            "behavior.actions[1+]",                  # At least one action
            "grounding.confidence"
        ],
        "minimum_score": 0.7
    },
    
    "artifact.physical": {
        "required_fields": [
            "definition",
            "categorical.chain",
            "function.primary_purpose",
            "structure_spatial.parts[1+]",
            "surface.visual",
            "grounding.confidence"
        ],
        "minimum_score": 0.6
    },
    
    "event": {
        "required_fields": [
            "definition",
            "categorical.chain",
            "temporal.start OR temporal.period",
            "causal.causes[1+]",
            "causal.effects[1+]",
            "grounding.confidence"
        ],
        "minimum_score": 0.6
    },
    
    # ... (similar for all types)
}


def calculate_completeness(concept, categorization):
    """
    Calculate how complete a concept's data is.
    """
    
    type_key = categorization["type"].split(".")[0]  # Get base type
    requirements = MINIMUM_REQUIREMENTS.get(type_key, {})
    
    required_fields = requirements.get("required_fields", [])
    minimum_score = requirements.get("minimum_score", 0.5)
    
    # Check each required field
    filled_required = 0
    missing_required = []
    
    for field_spec in required_fields:
        if field_exists_and_valid(concept, field_spec):
            filled_required += 1
        else:
            missing_required.append(field_spec)
    
    required_score = filled_required / len(required_fields) if required_fields else 1.0
    
    # Check recommended fields
    recommended_categories = categorization.get("recommended_categories", [])
    filled_recommended = sum(1 for cat in recommended_categories if category_has_data(concept, cat))
    recommended_score = filled_recommended / len(recommended_categories) if recommended_categories else 1.0
    
    # Calculate overall score (required weighted more)
    overall_score = (required_score * 0.8) + (recommended_score * 0.2)
    
    return {
        "required_complete": len(missing_required) == 0,
        "required_score": required_score,
        "recommended_score": recommended_score,
        "overall_score": overall_score,
        "meets_minimum": overall_score >= minimum_score,
        "missing_required": missing_required,
        "filled_required": filled_required,
        "total_required": len(required_fields)
    }


def validate_all_fields(concept):
    """
    Check data quality across all fields.
    """
    
    issues = []
    
    # Check ID format
    if not is_valid_id_format(concept.get("id")):
        issues.append({"field": "id", "issue": "Invalid ID format"})
    
    # Check categorical chain validity
    if "categorical" in concept and "chain" in concept["categorical"]:
        chain = concept["categorical"]["chain"]
        for i, item in enumerate(chain[:-1]):
            if not concept_exists(chain[i+1]):
                issues.append({
                    "field": "categorical.chain",
                    "issue": f"Parent '{chain[i+1]}' does not exist in system"
                })
    
    # Check composition references
    if "composition" in concept:
        for level in concept["composition"].get("levels", []):
            for component in level.get("components", []):
                if "ref" in component and not concept_exists(component["ref"]):
                    issues.append({
                        "field": "composition",
                        "issue": f"Component reference '{component['ref']}' does not exist"
                    })
    
    # Check relational references
    if "relational" in concept:
        for rel in concept["relational"].get("relationships", []):
            if "target_ref" in rel and not concept_exists(rel["target_ref"]):
                issues.append({
                    "field": "relational",
                    "issue": f"Relationship target '{rel['target_ref']}' does not exist"
                })
    
    # Check grounding confidence range
    if "grounding" in concept:
        conf = concept["grounding"].get("confidence")
        if conf is not None and not (0.0 <= conf <= 1.0):
            issues.append({
                "field": "grounding.confidence",
                "issue": f"Confidence {conf} out of range [0.0, 1.0]"
            })
    
    # Check spatial structure consistency
    if "structure_spatial" in concept:
        parts = concept["structure_spatial"].get("parts", [])
        for part in parts:
            relative_to = part.get("relative_to")
            if relative_to and relative_to != "center":
                if not any(p.get("name") == relative_to for p in parts):
                    issues.append({
                        "field": "structure_spatial",
                        "issue": f"Part '{part.get('name')}' references non-existent '{relative_to}'"
                    })
    
    return issues
```

---

# 9. The Relationship System

## 9.1 Relationship Types

All possible relationships between concepts:

### 9.1.1 Hierarchical Relationships

```python
HIERARCHICAL_RELATIONSHIPS = {
    
    "IS_A": {
        "description": "Type/instance relationship",
        "example": "Cat IS_A Mammal",
        "direction": "child → parent",
        "inverse": "HAS_INSTANCE",
        "transitive": True,
        "properties": {
            "allows_inheritance": True
        }
    },
    
    "INSTANCE_OF": {
        "description": "Specific instance to general class",
        "example": "'Whiskers' INSTANCE_OF Cat",
        "direction": "instance → class",
        "inverse": "HAS_INSTANCE",
        "transitive": False
    },
    
    "SUBTYPE_OF": {
        "description": "More specific type to more general",
        "example": "Persian SUBTYPE_OF Cat",
        "direction": "specific → general",
        "inverse": "HAS_SUBTYPE",
        "transitive": True
    }
}
```

### 9.1.2 Compositional Relationships

```python
COMPOSITIONAL_RELATIONSHIPS = {
    
    "PART_OF": {
        "description": "Component to whole",
        "example": "Paw PART_OF Cat",
        "direction": "part → whole",
        "inverse": "HAS_PART",
        "transitive": True,
        "properties": {
            "essential": "boolean - is part required for whole",
            "quantity": "how many of this part"
        }
    },
    
    "MADE_OF": {
        "description": "Material composition",
        "example": "Bone MADE_OF Calcium",
        "direction": "thing → material",
        "inverse": "MATERIAL_FOR",
        "transitive": True
    },
    
    "CONTAINS": {
        "description": "Container to contents",
        "example": "Cell CONTAINS Nucleus",
        "direction": "container → contained",
        "inverse": "CONTAINED_IN",
        "transitive": False
    }
}
```

### 9.1.3 Functional Relationships

```python
FUNCTIONAL_RELATIONSHIPS = {
    
    "USED_FOR": {
        "description": "Thing to its purpose",
        "example": "Hammer USED_FOR Driving_Nails",
        "direction": "thing → function",
        "inverse": "USES",
        "transitive": False
    },
    
    "ENABLES": {
        "description": "Thing that makes action possible",
        "example": "Legs ENABLES Walking",
        "direction": "enabler → action",
        "inverse": "ENABLED_BY",
        "transitive": False
    },
    
    "REQUIRES": {
        "description": "Dependency relationship",
        "example": "Fire REQUIRES Oxygen",
        "direction": "dependent → dependency",
        "inverse": "REQUIRED_BY",
        "transitive": True
    }
}
```

### 9.1.4 Causal Relationships

```python
CAUSAL_RELATIONSHIPS = {
    
    "CAUSES": {
        "description": "Direct causation",
        "example": "Fire CAUSES Heat",
        "direction": "cause → effect",
        "inverse": "CAUSED_BY",
        "transitive": True,  # Indirect causation
        "properties": {
            "strength": "strong/moderate/weak",
            "reliability": "always/usually/sometimes",
            "mechanism": "description of how"
        }
    },
    
    "PREVENTS": {
        "description": "Blocking relationship",
        "example": "Vaccine PREVENTS Disease",
        "direction": "blocker → blocked",
        "inverse": "PREVENTED_BY",
        "transitive": True
    },
    
    "TRIGGERS": {
        "description": "Initiates an event/process",
        "example": "Spark TRIGGERS Fire",
        "direction": "trigger → triggered",
        "inverse": "TRIGGERED_BY",
        "transitive": False
    }
}
```

### 9.1.5 Analogical Relationships

```python
ANALOGICAL_RELATIONSHIPS = {
    
    "ANALOGOUS_TO": {
        "description": "Similar function in different contexts",
        "example": "Cat_Paw ANALOGOUS_TO Human_Hand",
        "direction": "bidirectional",
        "inverse": "ANALOGOUS_TO",  # Self-inverse
        "transitive": False,
        "properties": {
            "basis": ["list of shared functional roles"],
            "strength": "0.0-1.0",
            "mapping": "part-to-part correspondence"
        }
    },
    
    "HOMOLOGOUS_TO": {
        "description": "Same evolutionary origin, may differ now",
        "example": "Whale_Flipper HOMOLOGOUS_TO Human_Arm",
        "direction": "bidirectional",
        "inverse": "HOMOLOGOUS_TO",
        "transitive": True
    },
    
    "METAPHOR_FOR": {
        "description": "Conceptual mapping",
        "example": "Time METAPHOR_FOR Money",
        "direction": "source → target",
        "inverse": "METAPHOR_FROM",
        "transitive": False,
        "properties": {
            "mappings": "how concepts map to each other"
        }
    }
}
```

### 9.1.6 Oppositional Relationships

```python
OPPOSITIONAL_RELATIONSHIPS = {
    
    "OPPOSITE_OF": {
        "description": "Antonym / polar opposite",
        "example": "Hot OPPOSITE_OF Cold",
        "direction": "bidirectional",
        "inverse": "OPPOSITE_OF",
        "transitive": False,
        "constraints": {
            "mutual_exclusion": True  # Cannot have both
        }
    },
    
    "COMPLEMENT_OF": {
        "description": "Completes each other",
        "example": "Lock COMPLEMENT_OF Key",
        "direction": "bidirectional",
        "inverse": "COMPLEMENT_OF",
        "transitive": False
    },
    
    "CONTRASTS_WITH": {
        "description": "Alternative / different option",
        "example": "Democracy CONTRASTS_WITH Monarchy",
        "direction": "bidirectional",
        "inverse": "CONTRASTS_WITH",
        "transitive": False,
        "properties": {
            "dimension": "what dimension they differ on"
        }
    }
}
```

### 9.1.7 Spatial/Temporal Relationships

```python
SPATIAL_TEMPORAL_RELATIONSHIPS = {
    
    "ADJACENT_TO": {
        "description": "Spatially next to",
        "example": "Wrist ADJACENT_TO Hand",
        "direction": "bidirectional",
        "inverse": "ADJACENT_TO",
        "transitive": False
    },
    
    "ABOVE": {
        "description": "Spatial position",
        "example": "Head ABOVE Body",
        "direction": "higher → lower",
        "inverse": "BELOW",
        "transitive": True
    },
    
    "INSIDE": {
        "description": "Spatial containment",
        "example": "Brain INSIDE Skull",
        "direction": "inner → outer",
        "inverse": "OUTSIDE",
        "transitive": True
    },
    
    "BEFORE": {
        "description": "Temporal sequence",
        "example": "Cause BEFORE Effect",
        "direction": "earlier → later",
        "inverse": "AFTER",
        "transitive": True
    },
    
    "DURING": {
        "description": "Temporal overlap",
        "example": "Battle_of_Britain DURING World_War_2",
        "direction": "contained → container",
        "inverse": "CONTAINS_TEMPORALLY",
        "transitive": True
    }
}
```

### 9.1.8 Social/Interactional Relationships

```python
SOCIAL_RELATIONSHIPS = {
    
    "PREYS_ON": {
        "description": "Predator-prey relationship",
        "example": "Cat PREYS_ON Mouse",
        "direction": "predator → prey",
        "inverse": "PREYED_BY",
        "transitive": False
    },
    
    "COMPETES_WITH": {
        "description": "Competition for resources",
        "example": "Lion COMPETES_WITH Hyena",
        "direction": "bidirectional",
        "inverse": "COMPETES_WITH",
        "transitive": False
    },
    
    "COOPERATES_WITH": {
        "description": "Mutualistic relationship",
        "example": "Bee COOPERATES_WITH Flower",
        "direction": "bidirectional",
        "inverse": "COOPERATES_WITH",
        "transitive": False
    },
    
    "CREATED_BY": {
        "description": "Creator relationship",
        "example": "Painting CREATED_BY Artist",
        "direction": "creation → creator",
        "inverse": "CREATES",
        "transitive": False
    },
    
    "OWNED_BY": {
        "description": "Ownership relationship",
        "example": "Car OWNED_BY Person",
        "direction": "owned → owner",
        "inverse": "OWNS",
        "transitive": False
    }
}
```

## 9.2 Complete Relationship Registry

```python
ALL_RELATIONSHIPS = {
    **HIERARCHICAL_RELATIONSHIPS,
    **COMPOSITIONAL_RELATIONSHIPS,
    **FUNCTIONAL_RELATIONSHIPS,
    **CAUSAL_RELATIONSHIPS,
    **ANALOGICAL_RELATIONSHIPS,
    **OPPOSITIONAL_RELATIONSHIPS,
    **SPATIAL_TEMPORAL_RELATIONSHIPS,
    **SOCIAL_RELATIONSHIPS
}

RELATIONSHIP_CATEGORIES = {
    "hierarchical": ["IS_A", "INSTANCE_OF", "SUBTYPE_OF"],
    "compositional": ["PART_OF", "MADE_OF", "CONTAINS"],
    "functional": ["USED_FOR", "ENABLES", "REQUIRES"],
    "causal": ["CAUSES", "PREVENTS", "TRIGGERS"],
    "analogical": ["ANALOGOUS_TO", "HOMOLOGOUS_TO", "METAPHOR_FOR"],
    "oppositional": ["OPPOSITE_OF", "COMPLEMENT_OF", "CONTRASTS_WITH"],
    "spatial": ["ADJACENT_TO", "ABOVE", "BELOW", "INSIDE", "OUTSIDE"],
    "temporal": ["BEFORE", "AFTER", "DURING", "CONTAINS_TEMPORALLY"],
    "social": ["PREYS_ON", "PREYED_BY", "COMPETES_WITH", "COOPERATES_WITH", 
               "CREATED_BY", "CREATES", "OWNED_BY", "OWNS"]
}

TRANSITIVE_RELATIONSHIPS = [
    "IS_A", "SUBTYPE_OF", "PART_OF", "MADE_OF", "REQUIRES",
    "CAUSES", "PREVENTS", "HOMOLOGOUS_TO",
    "ABOVE", "BELOW", "INSIDE", "BEFORE", "AFTER", "DURING"
]

BIDIRECTIONAL_RELATIONSHIPS = [
    "ANALOGOUS_TO", "HOMOLOGOUS_TO", "OPPOSITE_OF", "COMPLEMENT_OF",
    "CONTRASTS_WITH", "ADJACENT_TO", "COMPETES_WITH", "COOPERATES_WITH"
]
```

---

# 10. The Analogy Engine

## 10.1 Purpose

Find and quantify similarities between concepts, even when they're different types of things. Enable reasoning like "A cat's paw is like a human hand."

## 10.2 Functional Role System

Every concept can be tagged with functional roles that describe what it does:

```python
FUNCTIONAL_ROLE_TAXONOMY = {
    
    "locomotion": {
        "ground_contact": "Makes contact with ground for movement",
        "propulsion": "Provides force for movement",
        "balance": "Maintains stability",
        "steering": "Controls direction"
    },
    
    "manipulation": {
        "grasping": "Can hold objects",
        "precise": "Fine motor control",
        "limited": "Some manipulation ability",
        "tool_use": "Can use tools"
    },
    
    "sensory": {
        "touch": "Detects physical contact",
        "vision": "Detects light",
        "hearing": "Detects sound",
        "smell": "Detects chemicals (air)",
        "taste": "Detects chemicals (contact)",
        "proprioception": "Detects body position"
    },
    
    "protection": {
        "armor": "Physical barrier",
        "camouflage": "Visual concealment",
        "deterrent": "Discourages attack"
    },
    
    "communication": {
        "visual_signal": "Communicates via sight",
        "auditory_signal": "Communicates via sound",
        "chemical_signal": "Communicates via chemicals",
        "gesture": "Communicates via movement"
    },
    
    "metabolism": {
        "intake": "Takes in resources",
        "processing": "Transforms resources",
        "output": "Expels waste/products",
        "storage": "Holds resources"
    },
    
    "reproduction": {
        "gamete_production": "Creates reproductive cells",
        "mating": "Combines genetic material",
        "gestation": "Develops offspring",
        "birth": "Releases offspring"
    },
    
    "structural": {
        "support": "Bears weight/load",
        "connection": "Links parts together",
        "flexibility": "Allows movement between parts",
        "containment": "Encloses/holds contents"
    },
    
    "computation": {  # For technical systems
        "input": "Receives data",
        "processing": "Transforms data",
        "storage": "Holds data",
        "output": "Produces results"
    }
}
```

## 10.3 Similarity Calculation Methods

### 10.3.1 Functional Similarity

```python
def functional_role_similarity(concept_a, concept_b):
    """
    Compare concepts based on shared functional roles.
    """
    
    roles_a = set(concept_a.get("functional_roles", []))
    roles_b = set(concept_b.get("functional_roles", []))
    
    if not roles_a or not roles_b:
        return {"score": 0, "shared": [], "basis": "no_roles"}
    
    shared_roles = roles_a & roles








!!!Chat max context reach again!!!




# 10. The Analogy Engine (Continued)

## 10.3 Similarity Calculation Methods

### 10.3.1 Functional Similarity

```python
def functional_role_similarity(concept_a, concept_b):
    """
    Compare concepts based on shared functional roles.
    """
    
    roles_a = set(concept_a.get("functional_roles", []))
    roles_b = set(concept_b.get("functional_roles", []))
    
    if not roles_a or not roles_b:
        return {"score": 0, "shared": [], "basis": "no_roles"}
    
    shared_roles = roles_a & roles_b
    all_roles = roles_a | roles_b
    
    # Jaccard similarity
    score = len(shared_roles) / len(all_roles) if all_roles else 0
    
    return {
        "score": score,
        "shared": list(shared_roles),
        "only_a": list(roles_a - roles_b),
        "only_b": list(roles_b - roles_a),
        "basis": "functional_roles"
    }
```

### 10.3.2 Structural Similarity

```python
def structural_similarity(concept_a, concept_b):
    """
    Compare concepts based on how they're built/arranged.
    """
    
    score = 0.0
    breakdown = {}
    
    # Get structures (handle different structure types)
    struct_a = get_structure(concept_a)
    struct_b = get_structure(concept_b)
    
    if not struct_a or not struct_b:
        return {"score": 0, "breakdown": {}, "basis": "no_structure"}
    
    # Same structure type? (spatial vs temporal vs hierarchical)
    if struct_a["type"] == struct_b["type"]:
        score += 0.2
        breakdown["same_structure_type"] = True
    else:
        breakdown["same_structure_type"] = False
    
    # Compare part counts (for spatial structures)
    if "parts" in struct_a and "parts" in struct_b:
        parts_a = struct_a["parts"]
        parts_b = struct_b["parts"]
        
        count_ratio = min(len(parts_a), len(parts_b)) / max(len(parts_a), len(parts_b))
        score += 0.2 * count_ratio
        breakdown["part_count_similarity"] = count_ratio
        
        # Map parts by function/position
        part_mapping = map_similar_parts(parts_a, parts_b)
        mapping_score = len(part_mapping) / max(len(parts_a), len(parts_b))
        score += 0.3 * mapping_score
        breakdown["part_mapping_score"] = mapping_score
        breakdown["part_mapping"] = part_mapping
    
    # Compare overall shape
    if "overall" in struct_a and "overall" in struct_b:
        shape_a = struct_a["overall"].get("shape")
        shape_b = struct_b["overall"].get("shape")
        
        if shape_a and shape_b:
            shape_sim = shape_similarity(shape_a, shape_b)
            score += 0.15 * shape_sim
            breakdown["shape_similarity"] = shape_sim
    
    # Compare symmetry
    if "symmetry" in struct_a and "symmetry" in struct_b:
        if struct_a["symmetry"].get("type") == struct_b["symmetry"].get("type"):
            score += 0.15
            breakdown["same_symmetry"] = True
    
    return {
        "score": min(score, 1.0),
        "breakdown": breakdown,
        "basis": "structure"
    }


def map_similar_parts(parts_a, parts_b):
    """
    Find the best mapping between parts of two concepts.
    """
    
    mapping = []
    used_b = set()
    
    for part_a in parts_a:
        best_match = None
        best_score = 0.3  # Minimum threshold
        
        for i, part_b in enumerate(parts_b):
            if i in used_b:
                continue
            
            sim = part_similarity(part_a, part_b)
            if sim > best_score:
                best_score = sim
                best_match = (i, part_b)
        
        if best_match:
            used_b.add(best_match[0])
            mapping.append({
                "a": part_a.get("name"),
                "b": best_match[1].get("name"),
                "score": best_score,
                "basis": explain_part_similarity(part_a, best_match[1])
            })
    
    return mapping


def part_similarity(part_a, part_b):
    """
    Calculate similarity between two parts.
    """
    
    score = 0.0
    
    # Same functional role
    func_a = part_a.get("function") or part_a.get("functional_role")
    func_b = part_b.get("function") or part_b.get("functional_role")
    if func_a and func_b and func_a == func_b:
        score += 0.4
    
    # Similar relative position
    pos_a = part_a.get("relative_to")
    pos_b = part_b.get("relative_to")
    if pos_a and pos_b:
        if pos_a == pos_b or positions_equivalent(pos_a, pos_b):
            score += 0.2
    
    # Similar shape
    shape_a = part_a.get("shape")
    shape_b = part_b.get("shape")
    if shape_a and shape_b and shape_a == shape_b:
        score += 0.15
    
    # Same quantity
    qty_a = part_a.get("quantity", 1)
    qty_b = part_b.get("quantity", 1)
    if qty_a == qty_b:
        score += 0.1
    
    # Similar composition
    comp_a = part_a.get("made_of")
    comp_b = part_b.get("made_of")
    if comp_a and comp_b:
        comp_sim = composition_similarity(comp_a, comp_b)
        score += 0.15 * comp_sim
    
    return min(score, 1.0)
```

### 10.3.3 Categorical Distance

```python
def categorical_distance(concept_a, concept_b):
    """
    Calculate how far apart two concepts are in the type hierarchy.
    """
    
    chain_a = concept_a.get("categorical", {}).get("chain", [])
    chain_b = concept_b.get("categorical", {}).get("chain", [])
    
    if not chain_a or not chain_b:
        return {"score": 0, "common_ancestor": None, "distance": float('inf')}
    
    # Find first common ancestor
    common_ancestor = None
    distance_a = len(chain_a)
    distance_b = len(chain_b)
    
    for i, item_a in enumerate(chain_a):
        for j, item_b in enumerate(chain_b):
            if item_a.lower() == item_b.lower():
                if (i + j) < (distance_a + distance_b):
                    common_ancestor = item_a
                    distance_a = i
                    distance_b = j
                break
    
    if common_ancestor is None:
        # Check for root match
        if chain_a[-1].lower() == chain_b[-1].lower():
            common_ancestor = chain_a[-1]
            distance_a = len(chain_a) - 1
            distance_b = len(chain_b) - 1
    
    total_distance = distance_a + distance_b
    
    # Convert distance to similarity score (closer = higher score)
    # Score of 1.0 for same concept, decreasing with distance
    max_possible = len(chain_a) + len(chain_b) - 2
    if max_possible > 0:
        similarity = 1 - (total_distance / max_possible)
    else:
        similarity = 1.0 if total_distance == 0 else 0.0
    
    return {
        "score": max(0, similarity),
        "common_ancestor": common_ancestor,
        "distance": total_distance,
        "distance_a": distance_a,
        "distance_b": distance_b,
        "basis": "categorical_hierarchy"
    }
```

### 10.3.4 Relational Pattern Similarity

```python
def relational_pattern_similarity(concept_a, concept_b):
    """
    Compare how two concepts relate to other concepts.
    """
    
    rels_a = concept_a.get("relational", {}).get("relationships", [])
    rels_b = concept_b.get("relational", {}).get("relationships", [])
    
    if not rels_a or not rels_b:
        return {"score": 0, "shared_patterns": [], "basis": "no_relations"}
    
    score = 0.0
    shared_patterns = []
    
    # Extract relationship types
    types_a = set(r.get("type") for r in rels_a)
    types_b = set(r.get("type") for r in rels_b)
    
    shared_types = types_a & types_b
    all_types = types_a | types_b
    
    # Score for having same relationship types
    type_overlap = len(shared_types) / len(all_types) if all_types else 0
    score += 0.4 * type_overlap
    
    # For each shared relationship type, check if targets are analogous
    for rel_type in shared_types:
        targets_a = [r.get("target_name") for r in rels_a if r.get("type") == rel_type]
        targets_b = [r.get("target_name") for r in rels_b if r.get("type") == rel_type]
        
        # Check if targets are in same categories
        for ta in targets_a:
            for tb in targets_b:
                if targets_analogous(ta, tb):
                    shared_patterns.append({
                        "relationship": rel_type,
                        "a_target": ta,
                        "b_target": tb
                    })
                    score += 0.1
    
    return {
        "score": min(score, 1.0),
        "shared_patterns": shared_patterns,
        "shared_relationship_types": list(shared_types),
        "basis": "relational_patterns"
    }


def targets_analogous(target_a_name, target_b_name):
    """
    Check if two relationship targets are analogous.
    """
    
    # Look up the concepts
    concept_a = get_concept_by_name(target_a_name)
    concept_b = get_concept_by_name(target_b_name)
    
    if not concept_a or not concept_b:
        return False
    
    # Check categorical distance
    cat_result = categorical_distance(concept_a, concept_b)
    
    # Analogous if they share a reasonably close common ancestor
    return cat_result["distance"] <= 4
```

## 10.4 The Complete Analogy Finder

```python
def find_analogy(concept_a, concept_b):
    """
    Find and quantify the analogy between two concepts.
    Combines all similarity measures.
    """
    
    # Skip if same concept
    if concept_a.get("id") == concept_b.get("id"):
        return None
    
    # Calculate all similarity scores
    functional = functional_role_similarity(concept_a, concept_b)
    structural = structural_similarity(concept_a, concept_b)
    categorical = categorical_distance(concept_a, concept_b)
    relational = relational_pattern_similarity(concept_a, concept_b)
    
    scores = {
        "functional": functional["score"],
        "structural": structural["score"],
        "categorical": categorical["score"],
        "relational": relational["score"]
    }
    
    # Weighted combination
    weights = {
        "functional": 0.35,   # Most important: do they do similar things?
        "structural": 0.25,   # Are they built similarly?
        "categorical": 0.20,  # Are they the same kind of thing?
        "relational": 0.20    # Do they relate to other things similarly?
    }
    
    total_score = sum(scores[k] * weights[k] for k in scores)
    
    # Threshold for considering it an analogy
    if total_score < 0.3:
        return None
    
    # Determine the basis for the analogy
    basis = []
    if scores["functional"] > 0.4:
        basis.append("similar_function")
    if scores["structural"] > 0.4:
        basis.append("similar_structure")
    if scores["categorical"] > 0.4:
        basis.append("same_category")
    if scores["relational"] > 0.4:
        basis.append("similar_relations")
    
    # Generate part-to-part mapping
    part_mapping = structural.get("breakdown", {}).get("part_mapping", [])
    
    # Identify key differences
    differences = find_key_differences(concept_a, concept_b)
    
    return {
        "type": "ANALOGOUS_TO",
        "between": [concept_a.get("id"), concept_b.get("id")],
        "names": [concept_a.get("name"), concept_b.get("name")],
        "score": total_score,
        "basis": basis,
        "breakdown": {
            "functional": functional,
            "structural": structural,
            "categorical": categorical,
            "relational": relational
        },
        "part_mapping": part_mapping,
        "differences": differences
    }


def find_key_differences(concept_a, concept_b):
    """
    Identify important differences between two analogous concepts.
    """
    
    differences = []
    
    # Compare primary functions
    func_a = concept_a.get("function", {}).get("primary_purpose")
    func_b = concept_b.get("function", {}).get("primary_purpose")
    if func_a and func_b and func_a != func_b:
        differences.append({
            "aspect": "primary_function",
            "a": func_a,
            "b": func_b
        })
    
    # Compare sizes
    size_a = get_typical_size(concept_a)
    size_b = get_typical_size(concept_b)
    if size_a and size_b:
        if abs(size_a - size_b) / max(size_a, size_b) > 0.5:
            differences.append({
                "aspect": "size",
                "a": size_a,
                "b": size_b
            })
    
    # Compare part counts
    parts_a = len(concept_a.get("structure_spatial", {}).get("parts", []))
    parts_b = len(concept_b.get("structure_spatial", {}).get("parts", []))
    if parts_a != parts_b:
        differences.append({
            "aspect": "part_count",
            "a": parts_a,
            "b": parts_b
        })
    
    # Compare categorical chain (where they diverge)
    chain_a = concept_a.get("categorical", {}).get("chain", [])
    chain_b = concept_b.get("categorical", {}).get("chain", [])
    if chain_a and chain_b and chain_a[0] != chain_b[0]:
        differences.append({
            "aspect": "category",
            "a": chain_a[0] if chain_a else None,
            "b": chain_b[0] if chain_b else None
        })
    
    # Compare unique functional roles
    roles_a = set(concept_a.get("functional_roles", []))
    roles_b = set(concept_b.get("functional_roles", []))
    unique_a = roles_a - roles_b
    unique_b = roles_b - roles_a
    if unique_a or unique_b:
        differences.append({
            "aspect": "unique_functions",
            "only_a": list(unique_a),
            "only_b": list(unique_b)
        })
    
    return differences
```

## 10.5 Analogy Search

```python
def find_analogies_for(concept, concept_store, top_n=10, min_score=0.3):
    """
    Find the most analogous concepts to a given concept.
    """
    
    analogies = []
    
    for other_id, other_concept in concept_store.items():
        if other_id == concept.get("id"):
            continue
        
        analogy = find_analogy(concept, other_concept)
        
        if analogy and analogy["score"] >= min_score:
            analogies.append(analogy)
    
    # Sort by score, descending
    analogies.sort(key=lambda x: x["score"], reverse=True)
    
    return analogies[:top_n]


def find_concepts_with_similar_function(function_role, concept_store, min_score=0.5):
    """
    Find all concepts that share a particular functional role.
    """
    
    matches = []
    
    for concept_id, concept in concept_store.items():
        roles = concept.get("functional_roles", [])
        
        if function_role in roles:
            matches.append({
                "concept": concept,
                "roles": roles,
                "match_type": "exact"
            })
        else:
            # Check for related roles
            for role in roles:
                if roles_related(function_role, role):
                    matches.append({
                        "concept": concept,
                        "roles": roles,
                        "match_type": "related",
                        "matched_role": role
                    })
                    break
    
    return matches
```

---

# 11. The Logic Engine

## 11.1 Purpose

The Logic Engine applies formal rules to derive new knowledge, check consistency, and enable reasoning. It ensures the system can answer questions not explicitly stored.

## 11.2 Logic Rules

### 11.2.1 Inheritance Rules

```python
INHERITANCE_RULES = {
    
    "inherit_from_parent": {
        "description": "Properties flow down the IS_A hierarchy",
        "rule": """
            IF: A IS_A B
            AND: B has property P
            AND: P is marked as inheritable
            AND: A does not override P
            THEN: A has property P
        """,
        "example": {
            "given": ["Cat IS_A Mammal", "Mammal has warm_blooded=true"],
            "conclude": "Cat has warm_blooded=true"
        }
    },
    
    "inherit_capabilities": {
        "description": "Capabilities flow down unless overridden",
        "rule": """
            IF: A IS_A B
            AND: B has capability C
            AND: A does not explicitly lack C
            THEN: A has capability C
        """,
        "example": {
            "given": ["Cat IS_A Mammal", "Mammal can breathe_air"],
            "conclude": "Cat can breathe_air"
        }
    },
    
    "inherit_requirements": {
        "description": "Requirements flow down",
        "rule": """
            IF: A IS_A B
            AND: B REQUIRES X
            THEN: A REQUIRES X
        """,
        "example": {
            "given": ["Cat IS_A Mammal", "Mammal REQUIRES oxygen"],
            "conclude": "Cat REQUIRES oxygen"
        }
    }
}
```

### 11.2.2 Transitivity Rules

```python
TRANSITIVITY_RULES = {
    
    "transitive_is_a": {
        "description": "IS_A chains connect",
        "rule": """
            IF: A IS_A B
            AND: B IS_A C
            THEN: A IS_A C
        """,
        "example": {
            "given": ["Persian IS_A Cat", "Cat IS_A Mammal"],
            "conclude": "Persian IS_A Mammal"
        }
    },
    
    "transitive_part_of": {
        "description": "PART_OF chains connect",
        "rule": """
            IF: A PART_OF B
            AND: B PART_OF C
            THEN: A PART_OF C (transitively)
        """,
        "example": {
            "given": ["Claw PART_OF Paw", "Paw PART_OF Cat"],
            "conclude": "Claw PART_OF Cat"
        }
    },
    
    "transitive_causes": {
        "description": "CAUSES chains create indirect causation",
        "rule": """
            IF: A CAUSES B
            AND: B CAUSES C
            THEN: A indirectly_CAUSES C
        """,
        "example": {
            "given": ["Spark CAUSES Fire", "Fire CAUSES Heat"],
            "conclude": "Spark indirectly_CAUSES Heat"
        },
        "note": "Indirect causation has lower confidence"
    },
    
    "transitive_requires": {
        "description": "REQUIRES chains create indirect dependencies",
        "rule": """
            IF: A REQUIRES B
            AND: B REQUIRES C
            THEN: A indirectly_REQUIRES C
        """,
        "example": {
            "given": ["Running REQUIRES Muscles", "Muscles REQUIRES Protein"],
            "conclude": "Running indirectly_REQUIRES Protein"
        }
    },
    
    "transitive_before": {
        "description": "BEFORE chains connect",
        "rule": """
            IF: A BEFORE B
            AND: B BEFORE C
            THEN: A BEFORE C
        """,
        "example": {
            "given": ["Birth BEFORE Childhood", "Childhood BEFORE Adulthood"],
            "conclude": "Birth BEFORE Adulthood"
        }
    }
}
```

### 11.2.3 Inverse Rules

```python
INVERSE_RULES = {
    
    "inverse_relationships": {
        "description": "Relationships have inverses",
        "rules": [
            "IF A PART_OF B THEN B HAS_PART A",
            "IF A CAUSES B THEN B CAUSED_BY A",
            "IF A PREYS_ON B THEN B PREYED_BY A",
            "IF A BEFORE B THEN B AFTER A",
            "IF A ABOVE B THEN B BELOW A",
            "IF A INSIDE B THEN B CONTAINS A",
            "IF A CREATES B THEN B CREATED_BY A",
            "IF A OWNS B THEN B OWNED_BY A",
            "IF A REQUIRES B THEN B REQUIRED_BY A",
            "IF A ENABLES B THEN B ENABLED_BY A"
        ]
    }
}
```

### 11.2.4 Constraint Rules

```python
CONSTRAINT_RULES = {
    
    "mutual_exclusion": {
        "description": "Opposites cannot both be true",
        "rule": """
            IF: P OPPOSITE_OF Q
            THEN: NOT (X has P AND X has Q) simultaneously
        """,
        "example": {
            "given": ["Hot OPPOSITE_OF Cold"],
            "constraint": "Nothing can be both hot and cold at the same point"
        }
    },
    
    "dependency_satisfaction": {
        "description": "Requirements must be met",
        "rule": """
            IF: A REQUIRES B
            AND: X has/does A
            THEN: X must have/access B
        """,
        "example": {
            "given": ["Walking REQUIRES Legs", "Cat does Walking"],
            "conclude": "Cat must have Legs"
        }
    },
    
    "composition_completeness": {
        "description": "Essential parts must be present",
        "rule": """
            IF: P PART_OF T (marked essential)
            AND: X IS_A T
            THEN: X must have P
        """,
        "example": {
            "given": ["Heart PART_OF Mammal (essential)", "Cat IS_A Mammal"],
            "conclude": "Cat must have Heart"
        }
    },
    
    "type_constraints": {
        "description": "Type membership implies properties",
        "rule": """
            IF: X IS_A T
            AND: T has defining_property P
            THEN: X has P
        """,
        "example": {
            "given": ["Whiskers IS_A Cat", "Cat has defining_property: four_legs"],
            "conclude": "Whiskers has four_legs"
        }
    }
}
```

### 11.2.5 Analogy Transfer Rules

```python
ANALOGY_TRANSFER_RULES = {
    
    "analogical_inference": {
        "description": "Transfer properties between analogous concepts",
        "rule": """
            IF: A ANALOGOUS_TO B (with basis X)
            AND: A has property P
            AND: P relates to basis X
            THEN: B likely has analogous property P'
            WITH: confidence = analogy_score * property_relevance
        """,
        "example": {
            "given": [
                "Cat_Paw ANALOGOUS_TO Human_Hand (basis: manipulation)",
                "Cat_Paw has 'can grip branches'"
            ],
            "conclude": "Human_Hand likely has analogous gripping ability",
            "confidence": "high (directly related to basis)"
        }
    },
    
    "analogy_limits": {
        "description": "Cannot transfer properties unrelated to analogy basis",
        "rule": """
            IF: A ANALOGOUS_TO B (with basis X)
            AND: A has property P
            AND: P does NOT relate to basis X
            THEN: CANNOT infer B has P
        """,
        "example": {
            "given": [
                "Cat_Paw ANALOGOUS_TO Human_Hand (basis: manipulation)",
                "Cat_Paw has 'retractable claws'"
            ],
            "cannot_conclude": "Human_Hand has retractable anything",
            "reason": "retractable claws not related to manipulation"
        }
    },
    
    "analogy_mapping_transfer": {
        "description": "Use part mapping to transfer specific properties",
        "rule": """
            IF: A ANALOGOUS_TO B
            AND: part_mapping includes (A.part1 ↔ B.part2)
            AND: A.part1 has property P
            THEN: B.part2 may have analogous property
            WITH: confidence based on mapping score
        """,
        "example": {
            "given": [
                "Cat_Paw.claws ↔ Human_Hand.nails (mapping score: 0.7)",
                "Cat_Paw.claws are retractable"
            ],
            "weak_inference": "Human_Hand.nails might have some extensibility",
            "confidence": "low (property not well mapped)"
        }
    }
}
```

### 11.2.6 Causal Reasoning Rules

```python
CAUSAL_REASONING_RULES = {
    
    "effect_inheritance": {
        "description": "Subtypes inherit causal effects",
        "rule": """
            IF: A CAUSES B
            AND: X IS_A A
            THEN: X CAUSES B
        """,
        "example": {
            "given": ["Fire CAUSES Heat", "Campfire IS_A Fire"],
            "conclude": "Campfire CAUSES Heat"
        }
    },
    
    "prevention_blocking": {
        "description": "Preventing a cause prevents the effect",
        "rule": """
            IF: A CAUSES B
            AND: C PREVENTS A
            THEN: C indirectly_prevents B
        """,
        "example": {
            "given": ["Virus_Replication CAUSES Disease", "Vaccine PREVENTS Virus_Replication"],
            "conclude": "Vaccine prevents Disease"
        }
    },
    
    "causal_chains": {
        "description": "Trace causal chains for explanation",
        "rule": """
            IF: asking "why does X cause Z?"
            AND: X CAUSES Y
            AND: Y CAUSES Z
            THEN: explanation is "X causes Y, which causes Z"
        """,
        "use": "Generate explanatory chains"
    },
    
    "counterfactual_reasoning": {
        "description": "If cause removed, effect removed",
        "rule": """
            IF: A CAUSES B
            AND: A is the only cause of B
            THEN: NOT A implies NOT B
        """,
        "caution": "Only valid for sole causes"
    }
}
```

## 11.3 The Logic Engine Implementation

```python
class LogicEngine:
    """
    Applies logic rules to derive new knowledge and check consistency.
    """
    
    def __init__(self, concept_store, relationship_store):
        self.concepts = concept_store
        self.relationships = relationship_store
        self.rules = self._load_all_rules()
        self.inference_cache = {}
    
    def _load_all_rules(self):
        """Load all rule sets."""
        return {
            "inheritance": INHERITANCE_RULES,
            "transitivity": TRANSITIVITY_RULES,
            "inverse": INVERSE_RULES,
            "constraint": CONSTRAINT_RULES,
            "analogy": ANALOGY_TRANSFER_RULES,
            "causal": CAUSAL_REASONING_RULES
        }
    
    # ==================== QUERY METHODS ====================
    
    def query(self, question, context=None):
        """
        Answer a question using logical inference.
        """
        
        # Parse the question into logical form
        parsed = self.parse_question(question)
        
        # Try direct lookup first
        direct = self.direct_lookup(parsed)
        if direct["found"]:
            return {
                "answer": direct["answer"],
                "confidence": direct["confidence"],
                "method": "direct_lookup",
                "derivation": None
            }
        
        # Try inference via rules
        inferred = self.infer(parsed)
        if inferred["found"]:
            return {
                "answer": inferred["answer"],
                "confidence": inferred["confidence"],
                "method": "inference",
                "derivation": inferred["derivation"]
            }
        
        # Try analogy-based reasoning
        analogical = self.reason_by_analogy(parsed)
        if analogical["found"]:
            return {
                "answer": analogical["answer"],
                "confidence": analogical["confidence"],
                "method": "analogy",
                "derivation": analogical["derivation"]
            }
        
        return {
            "answer": None,
            "confidence": 0,
            "method": "none",
            "reason": "Could not determine answer"
        }
    
    def parse_question(self, question):
        """
        Parse natural language question into logical form.
        """
        
        # Identify question type
        question_lower = question.lower()
        
        if question_lower.startswith("is ") or question_lower.startswith("does "):
            q_type = "yes_no"
        elif question_lower.startswith("what "):
            q_type = "what"
        elif question_lower.startswith("why "):
            q_type = "why"
        elif question_lower.startswith("how "):
            q_type = "how"
        elif question_lower.startswith("can "):
            q_type = "capability"
        else:
            q_type = "unknown"
        
        # Extract subject and predicate (simplified)
        # In production, use NLP parser
        parsed = {
            "original": question,
            "type": q_type,
            "subject": self._extract_subject(question),
            "predicate": self._extract_predicate(question),
            "object": self._extract_object(question)
        }
        
        return parsed
    
    def direct_lookup(self, parsed):
        """
        Try to answer directly from stored data.
        """
        
        subject = parsed.get("subject")
        predicate = parsed.get("predicate")
        
        if not subject:
            return {"found": False}
        
        # Get the concept
        concept = self.get_concept(subject)
        if not concept:
            return {"found": False}
        
        # Look for the property
        if predicate:
            value = self.get_property(concept, predicate)
            if value is not None:
                return {
                    "found": True,
                    "answer": value,
                    "confidence": concept.get("grounding", {}).get("confidence", 0.8)
                }
        
        return {"found": False}
    
    def infer(self, parsed):
        """
        Apply logic rules to derive an answer.
        """
        
        subject = parsed.get("subject")
        predicate = parsed.get("predicate")
        q_type = parsed.get("type")
        
        concept = self.get_concept(subject)
        if not concept:
            return {"found": False}
        
        # Try inheritance rules
        inherited = self.apply_inheritance(concept, predicate)
        if inherited["found"]:
            return inherited
        
        # Try transitivity rules
        transitive = self.apply_transitivity(concept, predicate, parsed)
        if transitive["found"]:
            return transitive
        
        # Try constraint checking
        if q_type == "yes_no":
            constraint = self.check_constraints(concept, predicate)
            if constraint["determined"]:
                return {
                    "found": True,
                    "answer": constraint["answer"],
                    "confidence": constraint["confidence"],
                    "derivation": constraint["derivation"]
                }
        
        return {"found": False}
    
    def apply_inheritance(self, concept, property_name):
        """
        Check if property can be inherited from parent types.
        """
        
        chain = concept.get("categorical", {}).get("chain", [])
        
        for parent_name in chain[1:]:  # Skip self
            parent = self.get_concept(parent_name)
            if not parent:
                continue
            
            value = self.get_property(parent, property_name)
            if value is not None:
                # Check if property is inheritable
                if self.is_inheritable(parent, property_name):
                    return {
                        "found": True,
                        "answer": value,
                        "confidence": 0.9,  # Slightly reduced for inherited
                        "derivation": {
                            "rule": "inherit_from_parent",
                            "chain": [concept.get("name"), parent_name],
                            "property": property_name
                        }
                    }
        
        return {"found": False}
    
    def apply_transitivity(self, concept, predicate, parsed):
        """
        Apply transitive rules to find connections.
        """
        
        obj = parsed.get("object")
        
        if predicate in ["is_a", "type_of"]:
            # Check transitive IS_A
            chain = concept.get("categorical", {}).get("chain", [])
            if obj and obj.lower() in [c.lower() for c in chain]:
                return {
                    "found": True,
                    "answer": True,
                    "confidence": 1.0,
                    "derivation": {
                        "rule": "transitive_is_a",
                        "chain": chain[:chain.index(obj) + 1]
                    }
                }
        
        elif predicate in ["part_of", "component_of"]:
            # Check transitive PART_OF
            part_chain = self.find_part_of_chain(concept, obj)
            if part_chain:
                return {
                    "found": True,
                    "answer": True,
                    "confidence": 0.95,
                    "derivation": {
                        "rule": "transitive_part_of",
                        "chain": part_chain
                    }
                }
        
        elif predicate in ["causes", "leads_to"]:
            # Check transitive CAUSES
            causal_chain = self.find_causal_chain(concept, obj)
            if causal_chain:
                return {
                    "found": True,
                    "answer": True,
                    "confidence": 0.8 ** len(causal_chain),  # Decreases with chain length
                    "derivation": {
                        "rule": "transitive_causes",
                        "chain": causal_chain
                    }
                }
        
        return {"found": False}
    
    def reason_by_analogy(self, parsed):
        """
        Use analogical reasoning when direct logic fails.
        """
        
        subject = parsed.get("subject")
        predicate = parsed.get("predicate")
        
        concept = self.get_concept(subject)
        if not concept:
            return {"found": False}
        
        # Find analogous concepts
        analogies = find_analogies_for(concept, self.concepts, top_n=5, min_score=0.5)
        
        for analogy in analogies:
            source_id = analogy["between"][1]  # The other concept
            source = self.concepts.get(source_id)
            
            if not source:
                continue
            
            # Does the source have the property?
            source_value = self.get_property(source, predicate)
            
            if source_value is not None:
                # Check if property relates to analogy basis
                relevance = self.property_relevance_to_basis(predicate, analogy["basis"])
                
                if relevance > 0.5:
                    # Transfer the property
                    transferred = self.transfer_property(
                        source_value,
                        source,
                        concept,
                        analogy.get("part_mapping", [])
                    )
                    
                    return {
                        "found": True,
                        "answer": transferred,
                        "confidence": analogy["score"] * relevance * 0.8,  # Reduced for analogy
                        "derivation": {
                            "method": "analogy_transfer",
                            "source": source.get("name"),
                            "basis": analogy["basis"],
                            "relevance": relevance
                        }
                    }
        
        return {"found": False}
    
    # ==================== CONSISTENCY CHECKING ====================
    
    def check_consistency(self, concept):
        """
        Verify a concept doesn't violate logic rules.
        """
        
        violations = []
        
        # Check mutual exclusions
        violations.extend(self.check_mutual_exclusions(concept))
        
        # Check required parts
        violations.extend(self.check_required_parts(concept))
        
        # Check dependency satisfaction
        violations.extend(self.check_dependencies(concept))
        
        # Check type constraints
        violations.extend(self.check_type_constraints(concept))
        
        return {
            "consistent": len(violations) == 0,
            "violations": violations
        }
    
    def check_mutual_exclusions(self, concept):
        """Check for properties that cannot coexist."""
        
        violations = []
        
        # Get all properties of the concept
        properties = self.get_all_properties(concept)
        
        # Check each pair for mutual exclusion
        for prop_a in properties:
            opposite = self.get_opposite(prop_a)
            if opposite and opposite in properties:
                violations.append({
                    "type": "mutual_exclusion",
                    "properties": [prop_a, opposite],
                    "rule": f"{prop_a} OPPOSITE_OF {opposite}"
                })
        
        return violations
    
    def check_required_parts(self, concept):
        """Check that all essential parts are present."""
        
        violations = []
        
        # Get type chain
        chain = concept.get("categorical", {}).get("chain", [])
        
        for type_name in chain:
            type_concept = self.get_concept(type_name)
            if not type_concept:
                continue
            
            required_parts = self.get_required_parts(type_concept)
            
            for part in required_parts:
                if not self.concept_has_part(concept, part):
                    violations.append({
                        "type": "missing_required_part",
                        "part": part,
                        "required_by": type_name,
                        "rule": f"{part} PART_OF {type_name} (essential)"
                    })
        
        return violations
    
    def check_dependencies(self, concept):
        """Check that all dependencies are satisfied."""
        
        violations = []
        
        # Get capabilities/behaviors
        behaviors = concept.get("behavior", {}).get("actions", [])
        
        for behavior in behaviors:
            behavior_name = behavior.get("name")
            requirements = self.get_requirements(behavior_name)
            
            for req in requirements:
                if not self.concept_has(concept, req):
                    violations.append({
                        "type": "unsatisfied_dependency",
                        "behavior": behavior_name,
                        "missing_requirement": req,
                        "rule": f"{behavior_name} REQUIRES {req}"
                    })
        
        return violations
    
    def check_type_constraints(self, concept):
        """Check that type-specific constraints are met."""
        
        violations = []
        
        concept_type = concept.get("type")
        type_constraints = self.get_type_constraints(concept_type)
        
        for constraint in type_constraints:
            if not self.constraint_satisfied(concept, constraint):
                violations.append({
                    "type": "type_constraint_violation",
                    "constraint": constraint,
                    "concept_type": concept_type
                })
        
        return violations
    
    # ==================== GRAPH TRAVERSAL ====================
    
    def find_related(self, concept, relationship_type=None, direction="outgoing", depth=1):
        """
        Find concepts related to this one.
        """
        
        results = []
        visited = set()
        
        self._traverse_relations(
            concept,
            relationship_type,
            direction,
            depth,
            results,
            visited,
            current_depth=1
        )
        
        return results
    
    def _traverse_relations(self, concept, rel_type, direction, max_depth, results, visited, current_depth):
        """Recursive relation traversal."""
        
        concept_id = concept.get("id")
        if concept_id in visited:
            return
        visited.add(concept_id)
        
        relationships = concept.get("relational", {}).get("relationships", [])
        
        for rel in relationships:
            # Filter by relationship type if specified
            if rel_type and rel.get("type") != rel_type:
                continue
            
            # Filter by direction
            rel_direction = rel.get("direction", "outgoing")
            if direction != "both" and rel_direction != direction:
                continue
            
            target_ref = rel.get("target_ref")
            target = self.concepts.get(target_ref)
            
            if target:
                results.append({
                    "concept": target,
                    "relationship": rel.get("type"),
                    "distance": current_depth
                })
                
                # Recurse if depth allows
                if current_depth < max_depth:
                    self._traverse_relations(
                        target,
                        rel_type,
                        direction,
                        max_depth,
                        results,
                        visited,
                        current_depth + 1
                    )
    
    def find_path(self, source, target, relationship_types=None, max_depth=5):
        """
        Find a path between two concepts.
        """
        
        from collections import deque
        
        queue = deque([(source, [source.get("name")])])
        visited = {source.get("id")}
        
        while queue:
            current, path = queue.popleft()
            
            if current.get("id") == target.get("id"):
                return {"found": True, "path": path}
            
            if len(path) >= max_depth:
                continue
            
            relationships = current.get("relational", {}).get("relationships", [])
            
            for rel in relationships:
                if relationship_types and rel.get("type") not in relationship_types:
                    continue
                
                target_ref = rel.get("target_ref")
                if target_ref in visited:
                    continue
                
                next_concept = self.concepts.get(target_ref)
                if next_concept:
                    visited.add(target_ref)
                    new_path = path + [f"--{rel.get('type')}-->", next_concept.get("name")]
                    queue.append((next_concept, new_path))
        
        return {"found": False, "path": None}
    
    # ==================== HELPER METHODS ====================
    
    def get_concept(self, name_or_id):
        """Get a concept by name or ID."""
        
        # Try as ID first
        if name_or_id in self.concepts:
            return self.concepts[name_or_id]
        
        # Try as name
        for concept in self.concepts.values():
            if concept.get("name", "").lower() == name_or_id.lower():
                return concept
            if name_or_id.lower() in [a.lower() for a in concept.get("aliases", [])]:
                return concept
        
        return None
    
    def get_property(self, concept, property_path):
        """Get a property value from a concept using dot notation."""
        
        parts = property_path.split(".")
        current = concept
        
        for part in parts:
            if isinstance(current, dict):
                current = current.get(part)
            else:
                return None
            
            if current is None:
                return None
        
        return current
    
    def is_inheritable(self, concept, property_name):
        """Check if a property is marked as inheritable."""
        
        # By default, most properties are inheritable
        non_inheritable = ["id", "name", "instances", "specific_values"]
        return property_name not in non_inheritable
    
    def property_relevance_to_basis(self, property_name, basis):
        """Calculate how relevant a property is to an analogy basis."""
        
        # Map properties to functional areas
        property_areas = {
            "grip": ["manipulation", "similar_function"],
            "walk": ["locomotion", "similar_function"],
            "sense": ["sensory", "similar_function"],
            "size": ["similar_structure"],
            "shape": ["similar_structure"],
            "parts": ["similar_structure"],
            # ... more mappings
        }
        
        for keyword, areas in property_areas.items():
            if keyword in property_name.lower():
                for area in areas:
                    if area in basis:
                        return 0.8
        
        return 0.3  # Default low relevance
    
    def transfer_property(self, source_value, source_concept, target_concept, part_mapping):
        """Transfer a property from source to target, adapting as needed."""
        
        # Simple transfer for boolean/categorical properties
        if isinstance(source_value, bool):
            return source_value
        
        # For numeric properties, might need scaling
        if isinstance(source_value, (int, float)):
            # Scale based on size ratio if available
            source_size = self.get_typical_size(source_concept)
            target_size = self.get_typical_size(target_concept)
            
            if source_size and target_size:
                ratio = target_size / source_size
                return source_value * ratio
            
            return source_value
        
        # For string/descriptive properties, return with caveat
        return f"{source_value} (by analogy)"
```

---

# 12. Grounding and Confidence

## 12.1 The Grounding Chain

Every concept traces back to something solid through a grounding chain.

```python
GROUNDING_TYPES = {
    
    "perceptual": {
        "description": "Can be directly observed with senses or cameras",
        "examples": ["cat", "red color", "thunder sound"],
        "confidence_base": 0.95,
        "requirements": ["Observable by humans or instruments"]
    },
    
    "measurement": {
        "description": "Can be measured with instruments",
        "examples": ["mass", "temperature", "wavelength"],
        "confidence_base": 0.98,
        "requirements": ["Measurable quantity", "Defined units"]
    },
    
    "logical": {
        "description": "Follows necessarily from axioms/definitions",
        "examples": ["numbers", "geometric shapes", "logical operators"],
        "confidence_base": 1.0,
        "requirements": ["Formal definition", "Consistent axioms"]
    },
    
    "behavioral": {
        "description": "Repeatedly observed statistical regularity",
        "examples": ["cats hunt mice", "water boils at 100°C"],
        "confidence_base": 0.85,
        "requirements": ["Multiple observations", "Consistent pattern"]
    },
    
    "attestation": {
        "description": "Trusted humans/sources confirm",
        "examples": ["historical events", "expert knowledge"],
        "confidence_base": 0.70,
        "requirements": ["Credible sources", "Consensus or verification"]
    }
}


GROUNDING_CHAIN_EXAMPLES = {
    
    "cat": {
        "chain_depth": 1,
        "chain": ["Cat → directly observable"],
        "base_types": ["perceptual", "measurement"],
        "confidence": 0.99,
        "evidence": "Millions of photographs, physical specimens, scientific studies"
    },
    
    "democracy": {
        "chain_depth": 4,
        "chain": [
            "Democracy",
            "→ defined by institutions (elections, voting, representation)",
            "→ institutions observable via behaviors (people voting, debates)",
            "→ behaviors observable via physical actions",
            "→ physical actions directly perceptible"
        ],
        "base_types": ["behavioral", "attestation"],
        "confidence": 0.85,
        "evidence": "Observable voting processes, documented constitutions, historical records"
    },
    
    "love": {
        "chain_depth": 2,
        "chain": [
            "Love",
            "→ manifests in behaviors and physical signs",
            "→ behaviors/signs directly observable"
        ],
        "base_types": ["behavioral", "attestation"],
        "confidence": 0.80,
        "evidence": "Universal human reports, observable behaviors, physiological studies"
    },
    
    "number_seven": {
        "chain_depth": 0,
        "chain": ["7 → axiomatically defined"],
        "base_types": ["logical"],
        "confidence": 1.0,
        "evidence": "Mathematical definition: successor of 6"
    },
    
    "electron": {
        "chain_depth": 2,
        "chain": [
            "Electron",
            "→ inferred from experimental effects",
            "→ effects measurable (charge, tracks, interference)"
        ],
        "base_types": ["measurement", "behavioral"],
        "confidence": 0.95,
        "evidence": "Particle accelerator data, cathode ray experiments, quantum predictions"
    }
}
```

## 12.2 Confidence Calculation

```python
def calculate_grounding_confidence(concept):
    """
    Calculate overall confidence based on grounding chain.
    """
    
    grounding = concept.get("grounding", {})
    
    # Get base confidence from grounding type
    base_types = grounding.get("base_types", ["attestation"])
    base_confidence = max(
        GROUNDING_TYPES[bt]["confidence_base"]
        for bt in base_types
        if bt in GROUNDING_TYPES
    )
    
    # Reduce confidence based on chain depth
    chain_depth = grounding.get("chain_depth", len(grounding.get("chain", [])))
    depth_penalty = 0.02 * chain_depth  # 2% reduction per step
    
    # Reduce confidence if there's a weak link
    weak_link = grounding.get("weakest_link")
    weak_link_penalty = 0.1 if weak_link else 0
    
    # Calculate final confidence
    confidence = base_confidence - depth_penalty - weak_link_penalty
    
    return max(0.1, min(1.0, confidence))


def calculate_overall_confidence(concept, categorization, completeness):
    """
    Calculate overall concept confidence combining multiple factors.
    """
    
    # Grounding confidence (most important)
    grounding_conf = calculate_grounding_confidence(concept)
    
    # Completeness score
    completeness_conf = completeness.get("overall_score", 0.5)
    
    # Categorization confidence
    categorization_conf = categorization.get("confidence", 1.0)
    
    # Data quality (no validation issues = 1.0)
    quality_issues = len(concept.get("flags", []))
    quality_conf = 1.0 - (0.1 * quality_issues)
    
    # Weighted combination
    overall = (
        grounding_conf * 0.4 +
        completeness_conf * 0.3 +
        categorization_conf * 0.2 +
        quality_conf * 0.1
    )
    
    return max(0.1, min(1.0, overall))
```

## 12.3 Confidence Propagation

```python
def propagate_confidence(source_confidence, operation, *args):
    """
    Calculate confidence after various operations.
    """
    
    if operation == "inheritance":
        # Slight reduction for inherited properties
        return source_confidence * 0.95
    
    elif operation == "transitivity":
        chain_length = args[0] if args else 2
        # Reduce by 5% per step
        return source_confidence * (0.95 ** chain_length)
    
    elif operation == "analogy":
        analogy_score = args[0] if args else 0.5
        relevance = args[1] if len(args) > 1 else 0.5
        # Significant reduction for analogical reasoning
        return source_confidence * analogy_score * relevance * 0.8
    
    elif operation == "inference":
        rule_confidence = args[0] if args else 0.9
        return source_confidence * rule_confidence
    
    elif operation == "aggregation":
        # Multiple sources: use weighted average or max
        confidences = args[0] if args else [source_confidence]
        return sum(confidences) / len(confidences)
    
    else:
        return source_confidence
```

---

# 13. Variance and Inheritance

## 13.1 Three-Level System

```python
VARIANCE_SYSTEM = {
    
    "prototype": {
        "description": "The canonical/default form of a concept",
        "properties": {
            "canonical": True,
            "variance": "defines the allowed variance"
        },
        "example": "Cat (20.1004)"
    },
    
    "variant": {
        "description": "A recognized subtype with specific differences",
        "properties": {
            "inherits_from": "prototype ID",
            "overrides": "specific differences from prototype"
        },
        "example": "Persian Cat (20.1004.persian)"
    },
    
    "instance": {
        "description": "A specific individual",
        "properties": {
            "inherits_from": "prototype or variant ID",
            "specific_values": "exact values for this individual"
        },
        "example": "Whiskers (20.1004.instance.001)"
    }
}
```

## 13.2 Inheritance Resolution

```python
def resolve_property(concept, property_path):
    """
    Resolve a property, checking inheritance chain.
    """
    
    # Check if concept has the property directly
    direct_value = get_nested_property(concept, property_path)
    if direct_value is not None:
        return {
            "value": direct_value,
            "source": "direct",
            "concept": concept.get("id")
        }
    
    # Check inheritance chain
    inherits_from = concept.get("inherits_from")
    if inherits_from:
        parent = get_concept(inherits_from)
        if parent:
            # Check overrides first
            overrides = concept.get("overrides", {})
            if property_path in overrides:
                return {
                    "value": overrides[property_path],
                    "source": "override",
                    "concept": concept.get("id")
                }
            
            # Recurse to parent
            return resolve_property(parent, property_path)
    
    # Check categorical chain (type hierarchy)
    categorical = concept.get("categorical", {})
    chain = categorical.get("chain", [])
    
    for parent_name in chain[1:]:  # Skip self
        parent = get_concept_by_name(parent_name)
        if parent:
            parent_value = get_nested_property(parent, property_path)
            if parent_value is not None:
                return {
                    "value": parent_value,
                    "source": "inherited",
                    "concept": parent.get("id")
                }
    
    return {"value": None, "source": "not_found"}


def apply_variance(prototype, instance_values):
    """
    Create an instance by applying specific values to a prototype.
    """
    
    import copy
    
    # Deep copy the prototype
    instance = copy.deepcopy(prototype)
    
    # Generate instance ID
    instance["id"] = generate_instance_id(prototype["id"])
    instance["inherits_from"] = prototype["id"]
    
    # Apply specific values
    instance["specific_values"] = instance_values
    
    for path, value in instance_values.items():
        set_nested_property(instance, path, value)
    
    # Mark as instance
    instance["is_instance"] = True
    
    return instance


def check_variance_bounds(prototype, instance):
    """
    Check if an instance falls within the prototype's variance bounds.
    """
    
    violations = []
    
    variance = prototype.get("variance", {})
    dimensions = variance.get("dimensions", {})
    
    for dimension, bounds in dimensions.items():
        instance_value = get_nested_property(instance, dimension)
        
        if instance_value is None:
            continue
        
        # Check numeric bounds
        if "range" in bounds:
            min_val = bounds["range"].get("min")
            max_val = bounds["range"].get("max")
            
            if min_val is not None and instance_value < min_val:
                violations.append({
                    "dimension": dimension,
                    "value": instance_value,
                    "bound": f"min {min_val}",
                    "type": "below_minimum"
                })
            
            if max_val is not None and instance_value > max_val:
                violations.append({
                    "dimension": dimension,
                    "value": instance_value,
                    "bound": f"max {max_val}",
                    "type": "above_maximum"
                })
        
        # Check categorical bounds
        if "options" in bounds:
            if instance_value not in bounds["options"]:
                violations.append({
                    "dimension": dimension,
                    "value": instance_value,
                    "bound": f"options {bounds['options']}",
                    "type": "invalid_option"
                })
    
    return {
        "valid": len(violations) == 0,
        "violations": violations
    }
```

---

# 14. The Cognitive Loop

## 14.1 Overview

The complete process when the system receives a query.

```
USER QUERY
    │
    ▼
┌─────────────────────────────────────────────────────────┐
│  1. PERCEPTION: Parse and understand the query           │
│     - Query type (what, why, how, can, is)              │
│     - Subject identification                             │
│     - Predicate/property identification                  │
│     - Intent classification                              │
└─────────────────────────────────────────────────────────┘
    │
    ▼
┌─────────────────────────────────────────────────────────┐
│  2. RECALL: Retrieve relevant concepts                   │
│     - Primary concept lookup                             │
│     - Reasoning hooks → what categories to retrieve      │
│     - ChromaDB semantic search for related concepts      │
└─────────────────────────────────────────────────────────┘
    │
    ▼
┌─────────────────────────────────────────────────────────┐
│  3. NAVIGATION: Expand context via graph                 │
│     - Walk relationships from primary concept            │
│     - Load related concepts                              │
│     - Find analogies if needed                           │
│     - Trace causal chains if asking "why"                │
└─────────────────────────────────────────────────────────┘
    │
    ▼
┌─────────────────────────────────────────────────────────┐
│  4. REASONING: Apply logic to derive answer              │
│     - Direct lookup                                      │
│     - Inheritance rules                                  │
│     - Transitivity rules                                 │
│     - Analogy transfer (if direct logic fails)           │
│     - Constraint checking                                │
└─────────────────────────────────────────────────────────┘
    │
    ▼
┌─────────────────────────────────────────────────────────┐
│  5. SYNTHESIS: Assemble response packet                  │
│     - Verified facts from System A                       │
│     - Derivation chain (how we know)                     │
│     - Confidence scores                                  │
│     - Related concepts for context                       │
└─────────────────────────────────────────────────────────┘
    │
    ▼
┌─────────────────────────────────────────────────────────┐
│  6. GENERATION: LLM creates response                     │
│     - LLM receives structured context packet             │
│     - LLM CANNOT add facts not in packet                 │
│     - LLM synthesizes natural language response          │
│     - LLM cites concept IDs used                         │
└─────────────────────────────────────────────────────────┘
    │
    ▼
┌─────────────────────────────────────────────────────────┐
│  7. GATING: Verify response quality                      │
│     - Check all facts against cited concepts             │
│     - Verify confidence meets threshold                  │
│     - If invalid → trigger Deep Researcher               │
│     - If valid → deliver response                        │
└─────────────────────────────────────────────────────────┘
    │
    ▼
RESPONSE TO USER (or trigger learning if gaps found)
```

## 14.2 Implementation

```python
class CognitiveLoop:
    """
    The main query processing pipeline.
    """
    
    def __init__(self, concept_store, vector_store, logic_engine, llm):
        self.concepts = concept_store
        self.vectors = vector_store
        self.logic = logic_engine
        self.llm = llm
        self.confidence_threshold = 0.7
    
    def process_query(self, query, context=None):
        """
        Process a user query through the full cognitive loop.
        """
        
        # 1. PERCEPTION
        parsed = self.perceive(query)
        
        # 2. RECALL
        recalled = self.recall(parsed)
        
        # 3. NAVIGATION
        expanded = self.navigate(recalled, parsed)
        
        # 4. REASONING
        reasoned = self.reason(expanded, parsed)
        
        # 5. SYNTHESIS
        packet = self.synthesize(reasoned, parsed)
        
        # 6. GENERATION
        response = self.generate(packet, query)
        
        # 7. GATING
        final = self.gate(response, packet)
        
        return final
    
    def perceive(self, query):
        """
        Parse and understand the query.
        """
        
        # Identify query type
        query_lower = query.lower().strip()
        
        if query_lower.startswith(("what is", "what are", "what's")):
            q_type = "definition"
        elif query_lower.startswith(("why", "how come")):
            q_type = "explanation"
        elif query_lower.startswith(("how do", "how does", "how to")):
            q_type = "mechanism"
        elif query_lower.startswith(("can", "could", "is it possible")):
            q_type = "capability"
        elif query_lower.startswith(("is", "are", "does", "do")):
            q_type = "verification"
        elif query_lower.startswith(("compare", "difference", "similar")):
            q_type = "comparison"
        else:
            q_type = "general"
        
        # Extract key entities (simplified - use NLP in production)
        entities = self.extract_entities(query)
        
        # Determine what categories are likely needed
        reasoning_hints = self.get_reasoning_hints(q_type)
        
        return {
            "original": query,
            "type": q_type,
            "entities": entities,
            "reasoning_hints": reasoning_hints
        }
    
    def recall(self, parsed):
        """
        Retrieve relevant concepts from memory.
        """
        
        results = {
            "primary": [],
            "related": [],
            "semantic_matches": []
        }
        
        # Direct lookup for each entity
        for entity in parsed["entities"]:
            concept = self.logic.get_concept(entity)
            if concept:
                results["primary"].append(concept)
        
        # Semantic search for additional context
        semantic = self.vectors.search(
            parsed["original"],
            top_k=5
        )
        results["semantic_matches"] = semantic
        
        return results
    
    def navigate(self, recalled, parsed):
        """
        Expand context via graph traversal.
        """
        
        expanded = {
            "concepts": list(recalled["primary"]),
            "relationships": [],
            "analogies": [],
            "causal_chains": []
        }
        
        # For each primary concept, get related concepts
        for concept in recalled["primary"]:
            # Use reasoning hooks to determine what to retrieve
            hooks = concept.get("reasoning_hooks", {})
            hint_key = f"for_{parsed['type']}_query"
            
            categories_to_load = hooks.get(hint_key, [])
            
            # Get directly related concepts
            related = self.logic.find_related(
                concept,
                relationship_type=None,
                direction="both",
                depth=2
            )
            
            for rel in related:
                expanded["concepts"].append(rel["concept"])
                expanded["relationships"].append({
                    "from": concept.get("id"),
                    "to": rel["concept"].get("id"),
                    "type": rel["relationship"]
                })
            
            # If asking "why", trace causal chains
            if parsed["type"] == "explanation":
                causes = self.logic.find_related(
                    concept,
                    relationship_type="CAUSED_BY",
                    direction="outgoing",
                    depth=3
                )
                if causes:
                    expanded["causal_chains"].append({
                        "effect": concept.get("name"),
                        "causes": [c["concept"].get("name") for c in causes]
                    })
            
            # If comparison, find analogies
            if parsed["type"] == "comparison" and len(recalled["primary"]) >= 2:
                analogy = find_analogy(
                    recalled["primary"][0],
                    recalled["primary"][1]
                )
                if analogy:
                    expanded["analogies"].append(analogy)
        
        # Deduplicate concepts
        seen_ids = set()
        unique_concepts = []
        for c in expanded["concepts"]:
            cid = c.get("id")
            if cid not in seen_ids:
                seen_ids.add(cid)
                unique_concepts.append(c)
        expanded["concepts"] = unique_concepts
        
        return expanded
    
    def reason(self, expanded, parsed):
        """
        Apply logic to derive answers.
        """
        
        result = {
            "answer": None,
            "confidence": 0,
            "method": None,
            "derivation": None,
            "supporting_facts": []
        }
        
        # Try to answer the query
        logic_result = self.logic.query(parsed["original"])
        
        if logic_result["answer"] is not None:
            result["answer"] = logic_result["answer"]
            result["confidence"] = logic_result["confidence"]
            result["method"] = logic_result["method"]
            result["derivation"] = logic_result["derivation"]
        
        # Gather supporting facts from expanded concepts
        for concept in expanded["concepts"]:
            relevant_facts = self.extract_relevant_facts(concept, parsed)
            result["supporting_facts"].extend(relevant_facts)
        
        return result
    
    def synthesize(self, reasoned, parsed):
        """
        Assemble the context packet for the LLM.
        """
        
        packet = {
            "query": parsed["original"],
            "query_type": parsed["type"],
            
            "direct_answer": reasoned["answer"],
            "confidence": reasoned["confidence"],
            "derivation": reasoned["derivation"],
            
            "facts": reasoned["supporting_facts"],
            
            "constraints": [
                "You MUST NOT add facts not present in this packet",
                "You MUST cite concept IDs when stating facts",
                "You MUST indicate confidence level",
                "If confidence < 0.7, say 'I'm not certain, but...'"
            ]
        }
        
        return packet
    
    def generate(self, packet, original_query):
        """
        Have the LLM generate a natural language response.
        """
        
        # Build prompt for LLM
        prompt = f"""
You are answering a user's question using ONLY the verified facts provided below.
You CANNOT make up or add any facts not in this packet.
You MUST cite concept IDs when stating facts.

USER QUESTION: {original_query}

QUERY TYPE: {packet['query_type']}

DIRECT ANSWER (if available): {packet['direct_answer']}
CONFIDENCE: {packet['confidence']}
DERIVATION: {packet['derivation']}

VERIFIED FACTS:
{self.format_facts(packet['facts'])}

CONSTRAINTS:
- Only use facts from above
- Cite IDs in brackets like [20.1004]
- If confidence < 0.7, express uncertainty
- Be concise but complete

YOUR RESPONSE:
"""
        
        # Call LLM
        response = self.llm.generate(prompt)
        
        return {
            "text": response,
            "packet": packet,
            "citations": self.extract_citations(response)
        }
    
    def gate(self, response, packet):
        """
        Verify response quality before delivery.
        """
        
        # Check all citations are valid
        invalid_citations = []
        for citation in response["citations"]:
            if not self.verify_citation(citation, packet):
                invalid_citations.append(citation)
        
        # Check confidence threshold
        confidence = packet["confidence"]
        meets_threshold = confidence >= self.confidence_threshold
        
        if invalid_citations:
            # Response contains uncited facts - regenerate or flag
            return {
                "status": "invalid",
                "reason": "uncited_facts",
                "invalid_citations": invalid_citations,
                "action": "regenerate_or_research"
            }
        
        if not meets_threshold and "not certain" not in response["text"].lower():
            # Low confidence but not expressed - flag
            return {
                "status": "warning",
                "reason": "low_confidence_not_expressed",
                "confidence": confidence,
                "response": response["text"]
            }
        
        # All good
        return {
            "status": "valid",
            "response": response["text"],
            "confidence": confidence,
            "citations": response["citations"]
        }
    
    def format_facts(self, facts):
        """Format facts for the LLM prompt."""
        
        lines = []
        for fact in facts:
            lines.append(f"[{fact['concept_id']}] {fact['statement']} (confidence: {fact['confidence']})")
        return "\n".join(lines)
    
    def extract_citations(self, text):
        """Extract concept IDs cited in the response."""
        
        import re
        pattern = r'\[(\d+\.\d+(?:\.\w+)?)\]'
        return re.findall(pattern, text)
    
    def verify_citation(self, citation, packet):
        """Verify a citation refers to a fact in the packet."""
        
        for fact in packet["facts"]:
            if fact["concept_id"] == citation:
                return True
        return False
```

---

# 15. Complete Examples

## 15.1 Example: Full Concept Block (Cat)

```json
{
  "id": "20.1004",
  "name": "Cat",
  "aliases": ["feline", "kitty", "house cat", "Felis catus", "domestic cat"],
  "type": "organism.animal.mammal",
  
  "definition": "A small domesticated carnivorous mammal with soft fur, retractable claws, and keen senses, commonly kept as a pet.",
  
  "grounding": {
    "chain": ["Cat → directly observable animal"],
    "chain_depth": 1,
    "base_types": ["perceptual", "measurement"],
    "evidence_summary": "Directly observable animal with millions of documented specimens, photographs, and scientific studies across all inhabited continents.",
    "weakest_link": null,
    "confidence": 0.99
  },
  
  "categorical": {
    "chain": ["cat", "feline", "carnivore", "mammal", "vertebrate", "animal", "organism", "living thing", "physical object", "entity"],
    "siblings": ["dog", "bear", "seal", "raccoon", "weasel"],
    "distinguishing_features": ["retractable claws", "obligate carnivore", "solitary hunter", "domesticated", "vertical pupils"]
  },
  
  "composition": {
    "levels": [
      {
        "depth": 0,
        "name": "Organ Systems",
        "components": [
          {"name": "Skeletal System", "ref": "8.401.skeletal", "quantity": "one", "essential": true},
          {"name": "Muscular System", "ref": "8.401.muscular", "quantity": "one", "essential": true},
          {"name": "Nervous System", "ref": "8.401.nervous", "quantity": "one", "essential": true},
          {"name": "Circulatory System", "ref": "8.401.circulatory", "quantity": "one", "essential": true},
          {"name": "Respiratory System", "ref": "8.401.respiratory", "quantity": "one", "essential": true},
          {"name": "Digestive System", "ref": "8.401.digestive", "quantity": "one", "essential": true},
          {"name": "Integumentary System", "ref": "8.401.integumentary", "quantity": "one", "essential": true}
        ]
      },
      {
        "depth": 1,
        "name": "Major Organs",
        "components": [
          {"name": "Heart", "ref": "8.301.heart", "quantity": "one", "essential": true},
          {"name": "Brain", "ref": "8.301.brain", "quantity": "one", "essential": true},
          {"name": "Lungs", "ref": "8.301.lungs", "quantity": "two", "essential": true},
          {"name": "Liver", "ref": "8.301.liver", "quantity": "one", "essential": true},
          {"name": "Kidneys", "ref": "8.301.kidneys", "quantity": "two", "essential": true},
          {"name": "Stomach", "ref": "8.301.stomach", "quantity": "one", "essential": true}
        ]
      },
      {
        "depth": 2,
        "name": "Tissues",
        "components": [
          {"name": "Muscle Tissue", "ref": "8.201.muscle"},
          {"name": "Nerve Tissue", "ref": "8.201.nerve"},
          {"name": "Connective Tissue", "ref": "8.201.connective"},
          {"name": "Epithelial Tissue", "ref": "8.201.epithelial"}
        ]
      },
      {
        "depth": 3,
        "name": "Cells",
        "components": [
          {"name": "Animal Cell", "ref": "8.101.animal_cell"}
        ]
      }
    ],
    "base_layer": {
      "domain": "biology",
      "concept": "cell",
      "ref": "8.101"
    },
    "assembly": "Cells form tissues, tissues form organs, organs form organ systems, organ systems form complete organism"
  },
  
  "structure_spatial": {
    "center": {
      "name": "body_core",
      "description": "Central torso, reference point for all positions",
      "position": {"x": 0, "y": 0, "z": 0}
    },
    
    "overall": {
      "shape": "quadruped_form",
      "size": {
        "length": {"value": 45, "unit": "cm", "variance": "±15%"},
        "width": {"value": 20, "unit": "cm", "variance": "±15%"},
        "height": {"value": 25, "unit": "cm", "variance": "±15%"}
      }
    },
    
    "parts": [
      {
        "name": "head",
        "ref": "20.1004.head",
        "relative_to": "body_core",
        "position": {"x": 25, "y": 0, "z": 10, "unit": "cm"},
        "connection": {
          "type": "flexible_joint",
          "via": "neck",
          "degrees_of_freedom": {"pitch": 90, "yaw": 180, "roll": 45}
        },
        "shape": "round",
        "size": {"diameter": 10, "unit": "cm"},
        "contains": ["brain", "eyes", "ears", "nose", "mouth", "whiskers"]
      },
      {
        "name": "ears",
        "ref": "20.1004.ear",
        "quantity": 2,
        "relative_to": "head",
        "positions": [
          {"x": 3, "y": 0, "z": 5, "side": "left"},
          {"x": -3, "y": 0, "z": 5, "side": "right"}
        ],
        "angle": {"value": 45, "unit": "degrees", "direction": "outward"},
        "shape": "triangular",
        "size": {"height": 5, "width": 4, "unit": "cm"},
        "movable": true,
        "function": "hearing, expression"
      },
      {
        "name": "eyes",
        "ref": "20.1004.eye",
        "quantity": 2,
        "relative_to": "head",
        "positions": [
          {"x": 2, "y": 3, "z": 0, "side": "left"},
          {"x": -2, "y": 3, "z": 0, "side": "right"}
        ],
        "shape": "round with vertical pupil",
        "function": "vision, especially low-light"
      },
      {
        "name": "whiskers",
        "ref": "20.1004.whiskers",
        "quantity": 24,
        "relative_to": "head",
        "position": {"x": 0, "y": 4, "z": -1},
        "arrangement": "rows on either side of nose",
        "function": "spatial sensing, navigation"
      },
      {
        "name": "legs",
        "ref": "20.1004.leg",
        "quantity": 4,
        "relative_to": "body_core",
        "positions": [
          {"x": 15, "y": 8, "z": -12, "label": "front_left"},
          {"x": 15, "y": -8, "z": -12, "label": "front_right"},
          {"x": -15, "y": 8, "z": -12, "label": "back_left"},
          {"x": -15, "y": -8, "z": -12, "label": "back_right"}
        ],
        "joints": [
          {"name": "shoulder/hip", "degrees_of_freedom": 120},
          {"name": "elbow/knee", "degrees_of_freedom": 140},
          {"name": "wrist/ankle", "degrees_of_freedom": 90}
        ],
        "terminates_in": "paw"
      },
      {
        "name": "paws",
        "ref": "20.1004.paw",
        "quantity": 4,
        "relative_to": "legs",
        "position": "terminal end of each leg",
        "contains": ["pads", "claws", "digits"],
        "function": "locomotion, hunting, climbing"
      },
      {
        "name": "tail",
        "ref": "20.1004.tail",
        "relative_to": "body_core",
        "position": {"x": -25, "y": 0, "z": 0},
        "length": {"value": 25, "unit": "cm"},
        "flexible": true,
        "function": "balance, communication"
      }
    ],
    
    "symmetry": {
      "type": "bilateral",
      "axis": "y"
    }
  },
  
  "surface": {
    "visual": {
      "colors": {
        "common": ["orange", "gray", "black", "white", "brown"],
        "patterns": ["solid", "tabby", "calico", "tuxedo", "pointed", "tortoiseshell"]
      },
      "shape_impression": "small, compact quadruped with rounded features",
      "distinctive_features": ["pointed ears", "whiskers", "vertical pupils in bright light", "long tail"],
      "texture_appearance": "furry, soft-looking"
    },
    "auditory": {
      "sounds_produced": [
        {"name": "meow", "context": "communication with humans", "description": "variable pitch vocalization"},
        {"name": "purr", "context": "contentment, self-soothing, or illness", "frequency": "25-150 Hz"},
        {"name": "hiss", "context": "threat, fear", "description": "sharp exhale"},
        {"name": "chirp", "context": "excitement, hunting", "description": "short, bird-like sound"},
        {"name": "yowl", "context": "mating, distress", "description": "loud, prolonged cry"}
      ],
      "sounds_movement": "usually silent due to padded feet"
    },
    "tactile": {
      "texture": "soft fur over firm, muscular body",
      "temperature": "warm (38°C body temperature)",
      "notable": "rough tongue covered in papillae"
    },
    "olfactory": {
      "smell": "mild, distinctive 'cat smell' from skin oils",
      "notable": "urine has strong ammonia odor, used for territorial marking"
    },
    "size_impression": "small, fits in lap, can be picked up and carried",
    "overall_gestalt": "Small, soft, agile predator with an alert, independent demeanor"
  },
  
  "properties": {
    "physical": {
      "mass": {"typical": 4.5, "range": {"min": 2.5, "max": 7}, "unit": "kg"},
      "body_temperature": {"typical": 38.5, "range": {"min": 37.5, "max": 39.5}, "unit": "°C"},
      "heart_rate_resting": {"typical": 140, "range": {"min": 120, "max": 180}, "unit": "bpm"},
      "respiratory_rate": {"typical": 20, "range": {"min": 15, "max": 30}, "unit": "breaths/min"}
    },
    "intrinsic": {
      "intelligence": {"level": "high for non-primates", "evidence": "problem-solving, memory, learning"},
      "sociability": {"level": "variable", "range": "solitary to moderately social"},
      "trainability": {"level": "moderate", "notes": "can be trained but less eager to please than dogs"},
      "lifespan_typical": {"value": 15, "unit": "years", "range": {"min": 12, "max": 20}}
    },
    "abstract": {
      "domestication_level": {"value": "high", "scale": "wild→feral→semi-domestic→domestic"},
      "danger_to_humans": {"value": "low", "exceptions": "scratches, bites, allergies, toxoplasmosis"},
      "cultural_significance": {"value": "high", "examples": ["pets", "internet culture", "ancient Egypt worship"]}
    },
    "variable": {
      "hunger": {"range": [0, 1], "changes": "increases over time without food"},
      "energy": {"range": [0, 1], "changes": "decreases with activity, restored by sleep"},
      "mood": {"options": ["fearful", "alert", "calm", "playful", "aggressive", "affectionate"]}
    }
  },
  
  "functional_roles": [
    "locomotion.ground_contact",
    "locomotion.climbing",
    "locomotion.jumping",
    "manipulation.limited",
    "sensory.vision",
    "sensory.hearing",
    "sensory.touch",
    "sensory.smell",
    "predation.hunting",
    "predation.pouncing",
    "protection.claws",
    "communication.vocalization",
    "communication.body_language"
  ],
  
  "behavior": {
    "actions": [
      {
        "name": "hunting",
        "description": "Stalking, pouncing, capturing prey",
        "frequency": "instinctual, daily if outdoor",
        "conditions": "prey-like movement detected",
        "sequence": ["alert", "stalk", "crouch", "wiggle", "pounce", "capture", "kill_bite"]
      },
      {
        "name": "grooming",
        "description": "Licking fur to clean and regulate temperature",
        "frequency": "multiple times daily, 30-50% of waking hours",
        "conditions": "awake, feeling safe"
      },
      {
        "name": "sleeping",
        "description": "Rest periods, both light and deep sleep",
        "frequency": "12-16 hours per day",
        "conditions": "safe, comfortable location"
      },
      {
        "name": "scratching",
        "description": "Scratching surfaces to maintain claws and mark territory",
        "frequency": "daily",
        "conditions": "suitable surface available"
      },
      {
        "name": "kneading",
        "description": "Pushing paws alternately against soft surface",
        "frequency": "when content or seeking comfort",
        "origin": "kitten nursing behavior"
      }
    ],
    "reactions": [
      {"trigger": "sudden loud noise", "response": "startle, flee, or freeze", "reliability": "almost always"},
      {"trigger": "unfamiliar person approaching", "response": "assess, hide, or flee", "reliability": "usually"},
      {"trigger": "petting by trusted human", "response": "purring, relaxation, possible kneading", "reliability": "usually"},
      {"trigger": "cornered by threat", "response": "hiss, arch back, swipe with claws", "reliability": "almost always"},
      {"trigger": "prey-like movement", "response": "alert, stalk, pounce", "reliability": "almost always"}
    ],
    "capabilities": [
      "jump up to 6 times body length vertically",
      "always land on feet (righting reflex)",
      "see in 1/6th the light humans need",
      "hear frequencies up to 64 kHz (ultrasonic)",
      "run up to 30 mph in short bursts",
      "rotate ears 180 degrees independently",
      "retract claws fully into paw"
    ],
    "limitations": [
      "cannot taste sweetness (lack taste receptors)",
      "cannot digest plant matter efficiently (obligate carnivore)",
      "cannot see in complete darkness (need some light)",
      "poor long-distance runner (built for sprints)",
      "cannot see clearly closer than 30cm"
    ]
  },
  
  "function": {
    "primary_purpose": {
      "natural": "small predator, controls rodent populations in ecosystem",
      "human_context": "companion animal, pest control"
    },
    "secondary_purposes": [
      "emotional support",
      "therapy animal",
      "internet content/entertainment",
      "cultural/religious symbol (historical)"
    ],
    "serves": [
      {"beneficiary": "self", "how": "survival, reproduction"},
      {"beneficiary": "humans", "how": "companionship, pest control, emotional support"},
      {"beneficiary": "ecosystem", "how": "population control of small animals"}
    ],
    "role_in_system": {
      "system": "domestic household",
      "role": "pet, companion, pest deterrent"
    }
  },
  
  "temporal": {
    "lifecycle": [
      {
        "stage": "kitten",
        "duration": {"value": 6, "unit": "months"},
        "characteristics": ["dependent on mother", "rapid growth", "eyes open at 7-10 days", "weaning at 8 weeks", "socialization window"],
        "transitions_to": "juvenile",
        "transition_trigger": "weaning complete, size threshold"
      },
      {
        "stage": "juvenile",
        "duration": {"value": 6, "unit": "months"},
        "characteristics": ["independent", "very playful", "reaching sexual maturity"],
        "transitions_to": "adult",
        "transition_trigger": "sexual maturity (6-9 months)"
      },
      {
        "stage": "adult",
        "duration": {"value": 10, "unit": "years", "range": "8-15"},
        "characteristics": ["fully grown", "stable behavior", "capable of reproduction"],
        "transitions_to": "senior",
        "transition_trigger": "age 10-12 years, declining function"
      },
      {
        "stage": "senior",
        "duration": {"value": 5, "unit": "years", "range": "3-8"},
        "characteristics": ["reduced activity", "possible health issues", "more sleep", "may become more affectionate"],
        "transitions_to": "death",
        "transition_trigger": "organ failure, disease, age-related decline"
      }
    ],
    "states": [
      {"state": "awake_alert", "typical_duration": "hours", "characteristics": "ears forward, eyes wide"},
      {"state": "awake_relaxed", "typical_duration": "hours", "characteristics": "slow blink, loose posture"},
      {"state": "sleeping_light", "typical_duration": "15-30 min cycles", "characteristics": "easily woken"},
      {"state": "sleeping_deep", "typical_duration": "5-10 min periods", "characteristics": "may twitch, hard to wake"},
      {"state": "hunting_mode", "typical_duration": "minutes", "characteristics": "intense focus, low crouch"},
      {"state": "frightened", "typical_duration": "minutes to hours", "characteristics": "dilated pupils, flat ears"}
    ],
    "lifespan": {
      "typical": {"value": 15, "unit": "years"},
      "range": {"min": 10, "max": 20, "unit": "years"},
      "record": {"value": 38, "unit": "years", "note": "oldest recorded cat"},
      "factors": ["indoor vs outdoor (indoor +5-10 years)", "breed", "healthcare", "diet", "genetics"]
    }
  },
  
  "causal": {
    "requires": [
      {"what": "food (protein-based)", "necessity": "required", "frequency": "1-2 times daily"},
      {"what": "water", "necessity": "required", "frequency": "daily"},
      {"what": "shelter", "necessity": "required for survival"},
      {"what": "taurine (amino acid)", "necessity": "required", "note": "cannot synthesize, must get from meat"}
    ],
    "produces": [
      {"what": "waste (feces, urine)", "frequency": "daily"},
      {"what": "hairballs", "frequency": "periodic, especially long-haired cats"},
      {"what": "shed fur", "frequency": "continuous, seasonal peaks"},
      {"what": "offspring", "conditions": "mating, female not spayed", "quantity": "3-5 per litter"}
    ],
    "causes": [
      {"effect": "reduction in local rodent population", "mechanism": "predation", "strength": "moderate to strong"},
      {"effect": "reduction in local bird population", "mechanism": "predation", "strength": "moderate (outdoor cats)"},
      {"effect": "human allergic reactions", "mechanism": "Fel d 1 protein in saliva/skin", "affects": "~10% of humans"},
      {"effect": "toxoplasmosis transmission", "mechanism": "parasite in feces", "risk": "low with hygiene"}
    ],
    "caused_by": [
      {"cause": "African wildcat (Felis lybica)", "mechanism": "evolution/domestication", "timeframe": "~10,000 years ago"},
      {"cause": "human agricultural settlements", "mechanism": "attracted by rodents around grain stores"}
    ],
    "prevents": [
      {"what": "rodent infestation", "mechanism": "predation + scent deterrence", "effectiveness": "moderate to high"}
    ]
  },
  
  "relational": {
    "relationships": [
      {"type": "PREYS_ON", "target_ref": "20.1022", "target_name": "Mouse", "strength": "strong"},
      {"type": "PREYS_ON", "target_ref": "20.1087", "target_name": "Bird", "strength": "moderate"},
      {"type": "PREYS_ON", "target_ref": "20.1045", "target_name": "Insect", "strength": "moderate"},
      {"type": "PREYED_BY", "target_ref": "20.1055", "target_name": "Coyote", "strength": "moderate", "context": "outdoor cats"},
      {"type": "PREYED_BY", "target_ref": "20.1090", "target_name": "Eagle", "strength": "low", "context": "small cats, kittens"},
      {"type": "DOMESTICATED_BY", "target_ref": "20.0001", "target_name": "Human", "strength": "strong", "duration": "~10,000 years"},
      {"type": "COMPETES_WITH", "target_ref": "20.1005", "target_name": "Dog", "strength": "low", "context": "for human attention"},
      {"type": "DESCENDED_FROM", "target_ref": "20.1099", "target_name": "African Wildcat", "strength": "strong"}
    ],
    "contrasts_with": [
      {"concept_ref": "20.1005", "concept_name": "Dog", "dimensions": ["sociability", "trainability", "pack vs solitary"]}
    ],
    "similar_to": [
      {"concept_ref": "20.1055", "concept_name": "Lion", "similarity": "body plan, hunting behavior", "difference": "size, social structure"},
      {"concept_ref": "20.1056", "concept_name": "Tiger", "similarity": "body plan, solitary nature", "difference": "size, habitat"}
    ],
    "part_of": [
      {"whole_ref": "family.felidae", "whole_name": "Felidae (cat family)"},
      {"whole_ref": "ecosystem.domestic", "whole_name": "Domestic/urban ecosystem"}
    ]
  },
  
  "contextual": {
    "typical_location": {
      "places": ["homes", "apartments", "farms", "streets (feral)", "shelters"],
      "environments": ["urban", "suburban", "rural"],
      "specifics": "anywhere humans live, plus feral populations worldwide"
    },
    "conditions": {
      "required": {
        "temperature": {"min": -20, "max": 45, "unit": "°C", "notes": "with shelter"},
        "food": "regular protein source"
      },
      "optimal": {
        "temperature": {"min": 18, "max": 28, "unit": "°C"},
        "environment": "safe, warm, with hiding spots and vertical space"
      },
      "fatal": {
        "temperature_extreme": {"below": -30, "above": 50, "unit": "°C"},
        "other": ["prolonged starvation", "dehydration", "certain toxins (lilies, antifreeze)"]
      }
    },
    "distribution": {
      "geographic": "worldwide except Antarctica",
      "population_estimate": "~600 million domestic, ~100 million feral",
      "density": "highest in urban areas"
    },
    "era": {
      "origin": "~10,000 years ago (Fertile Crescent)",
      "peak_popularity": "present day (most popular pet globally)"
    },
    "cultural_context": {
      "ancient_egypt": "sacred animal, associated with goddess Bastet, mummified",
      "medieval_europe": "associated with witchcraft, often persecuted",
      "japan": "good luck symbol (maneki-neko)",
      "islam": "respected, considered clean",
      "modern_west": "beloved pet, internet celebrity, 'cat person' identity"
    }
  },
  
  "variance": {
    "dimensions": {
      "size": {"variance": "±30%", "range": {"min": "2kg", "max": "10kg"}, "factors": ["breed", "diet"]},
      "color": {"variance": "high", "options": ["solid", "tabby", "bicolor", "tricolor", "pointed"]},
      "fur_length": {"variance": "moderate", "options": ["hairless", "short", "medium", "long"]},
      "temperament": {"variance": "moderate", "range": ["very shy", "shy", "moderate", "friendly", "very friendly"]}
    },
    "what_stays_constant": [
      "basic body plan (quadruped, head, four legs, tail)",
      "obligate carnivore diet requirement",
      "retractable claws",
      "hunting instincts",
      "general size range (small enough to be household pet)"
    ]
  },
  
  "variants": [
    {
      "name": "Persian",
      "ref": "20.1004.persian",
      "overrides": {
        "structure_spatial.parts.head.shape": "flat (brachycephalic)",
        "surface.visual.texture_appearance": "long, fluffy fur",
        "properties.intrinsic.activity_level": "low",
        "behavior.actions.grooming.frequency": "requires human assistance"
      }
    },
    {
      "name": "Siamese",
      "ref": "20.1004.siamese",
      "overrides": {
        "surface.visual.colors.pattern": "pointed (light body, dark extremities)",
        "surface.auditory.sounds_produced.meow": "more frequent, louder, distinctive",
        "properties.intrinsic.sociability": "high, dog-like"
      }
    },
    {
      "name": "Maine Coon",
      "ref": "20.1004.maine_coon",
      "overrides": {
        "properties.physical.mass.typical": 8,
        "properties.physical.mass.range.max": 12,
        "surface.visual.texture_appearance": "long, shaggy fur",
        "properties.intrinsic.sociability": "high"
      }
    }
  ],
  
  "instances": [
    {
      "name": "Whiskers",
      "ref": "20.1004.instance.001",
      "specific_values": {
        "surface.visual.colors.common": ["orange", "white"],
        "surface.visual.colors.pattern": "tabby",
        "properties.physical.mass.value": 5.2,
        "contextual.typical_location.places": ["123 Main St"],
        "relational.relationships": [{"type": "OWNED_BY", "target_name": "Shane"}]
      }
    }
  ],
  
  "reasoning_hooks": {
    "for_definition_query": ["definition", "categorical", "surface.overall_gestalt"],
    "for_appearance_query": ["surface", "structure_spatial.overall", "structure_spatial.parts"],
    "for_movement_query": ["structure_spatial.parts.legs", "behavior.capabilities", "properties.physical"],
    "for_biology_query": ["composition", "properties.physical", "temporal.lifecycle"],
    "for_behavior_query": ["behavior", "function", "relational"],
    "for_care_query": ["causal.requires", "contextual.conditions", "temporal.lifecycle"],
    "for_comparison_query": ["categorical", "relational.similar_to", "relational.contrasts_with"],
    "for_spatial_reasoning": ["structure_spatial"],
    "for_capability_query": ["behavior.capabilities", "behavior.limitations", "structure_spatial"]
  },
  
  "confidence": 0.98,
  "completeness": {
    "required_complete": true,
    "overall_score": 0.95
  },
  "flags": [],
  "last_updated": "2024-01-15",
  "sources": ["veterinary literature", "biological databases", "common knowledge"]
}
```

## 15.2 Example: Analogy Query

**Query**: "How is a cat's paw like a human hand?"

**System Process**:

```python
# 1. Retrieve both concepts
cat_paw = concepts.get("20.1004.paw")
human_hand = concepts.get("20.0001.hand")

# 2. Run analogy engine
analogy = find_analogy(cat_paw, human_hand)

# 3. Result
{
    "type": "ANALOGOUS_TO",
    "between": ["20.1004.paw", "20.0001.hand"],
    "names": ["Cat Paw", "Human Hand"],
    "score": 0.78,
    "basis": ["similar_function", "similar_structure", "same_category"],
    
    "breakdown": {
        "functional": {
            "score": 0.65,
            "shared": ["sensory.touch", "manipulation.limited"],
            "only_a": ["locomotion.ground_contact", "predation.claws"],
            "only_b": ["manipulation.precise", "tool_use.primary"]
        },
        "structural": {
            "score": 0.82,
            "part_mapping": [
                {"a": "pad", "b": "palm", "score": 0.85, "basis": "base_surface"},
                {"a": "digits", "b": "fingers", "score": 0.90, "basis": "projections, similar count"},
                {"a": "claws", "b": "nails", "score": 0.70, "basis": "keratin tips"},
                {"a": "wrist_joint", "b": "wrist", "score": 0.95, "basis": "same joint type"}
            ]
        },
        "categorical": {
            "score": 0.90,
            "common_ancestor": "appendage_terminus",
            "distance": 2
        },
        "relational": {
            "score": 0.70,
            "shared_patterns": [
                {"relationship": "PART_OF", "a_target": "Cat", "b_target": "Human"},
                {"relationship": "CONNECTED_TO", "a_target": "Leg", "b_target": "Arm"}
            ]
        }
    },
    
    "differences": [
        {"aspect": "primary_function", "a": "locomotion", "b": "manipulation"},
        {"aspect": "digit_count", "a": 4, "b": 5},
        {"aspect": "retractable_claws", "a": true, "b": false},
        {"aspect": "opposable_thumb", "a": false, "b": true}
    ]
}
```

**LLM Response** (generated from the packet):

> A cat's paw and a human hand share several structural similarities [20.1004.paw, 20.0001.hand]. Both have:
> 
> - A central pad/palm that provides a base surface
> - Multiple digits extending from that base (4 in cats, 5 in humans)
> - Keratin coverings at the digit tips (claws vs nails)
> - A wrist joint connecting to the limb
> 
> They also share functions: both provide tactile sensing and some grasping ability.
> 
> However, they differ significantly in primary purpose. The cat's paw is optimized for locomotion and hunting (with retractable claws), while the human hand is optimized for precise manipulation (with an opposable thumb). Cats cannot perform the fine motor tasks humans can, and humans cannot retract their nails or walk on their hands effectively.
> 
> Confidence: High (0.78 analogy score)

---

## 15.3 Example: Logic Inference

**Query**: "Can a Persian cat jump as high as a regular cat?"

**System Process**:

```python
# 1. Parse query
parsed = {
    "type": "capability",
    "subject": "Persian cat",
    "predicate": "jump_height",
    "comparison_to": "regular cat"
}

# 2. Retrieve concepts
persian = concepts.get("20.1004.persian")  # Variant
cat = concepts.get("20.1004")               # Prototype

# 3. Resolve capability via inheritance
persian_jump = resolve_property(persian, "behavior.capabilities.jump")

# Result: Not directly specified in Persian, so inherit from Cat
# inheritance_chain: Persian → Cat → "jump up to 6x body length"

# 4. Check for overrides or modifications
persian_overrides = persian.get("overrides", {})
# Found: "properties.intrinsic.activity_level": "low"

# 5. Apply reasoning
reasoning = """
- Persian inherits jump capability from Cat [20.1004]
- Cat can jump up to 6x body length
- However, Persian has override: activity_level = low
- Persian also has override: body shape = brachycephalic (affects breathing)
- Inference: Physical capability present but may be reduced
"""

# 6. Build answer
answer = {
    "value": "Reduced compared to typical cat",
    "confidence": 0.75,
    "derivation": {
        "method": "inheritance + override consideration",
        "base_capability": "jump up to 6x body length (from Cat)",
        "modifiers": [
            "low activity level (Persian override)",
            "brachycephalic (breathing limitations)",
            "often heavier body (breed characteristic)"
        ],
        "conclusion": "Physical capability exists but typically less utilized and possibly reduced"
    }
}
```

**LLM Response**:

> Persian cats inherit the jumping capability from the cat prototype [20.1004] - cats can typically jump up to 6 times their body length. However, Persians have some characteristics that may reduce their jumping performance [20.1004.persian]:
> 
> 1. They have a lower activity level than typical cats
> 2. Their brachycephalic (flat-faced) structure can affect breathing during exertion
> 3. They tend to be heavier-bodied
> 
> So while a Persian *can* jump, they typically don't jump as high or as often as more athletic breeds. A typical cat might easily jump to a 6-foot shelf, while a Persian might prefer staying at lower heights.
> 
> Confidence: Moderate (0.75) - based on inherited capability modified by breed characteristics.

---

# Summary

This document specifies the complete WMCS architecture:

1. **The Problem**: LLMs hallucinate because they lack grounded understanding
2. **The Solution**: Two-brain architecture separating knowledge (System A) from language (System B)
3. **Constructive Understanding**: Concepts built from the ground up with explicit structure
4. **Complete Type System**: 50+ types covering physical, abstract, temporal, and meta concepts
5. **Universal Categories**: 30+ category types with detailed field specifications
6. **Type Categorization Engine**: Decision tree any model can follow
7. **Data Filling System**: Explicit questions to populate all fields
8. **Relationship System**: 30+ relationship types with properties
9. **Analogy Engine**: Multi-factor similarity detection and mapping
10. **Logic Engine**: Inheritance, transitivity, constraints, and inference rules
11. **Grounding System**: Trace every concept back to perceptual/logical foundation
12. **Variance System**: Prototype → Variant → Instance hierarchy
13. **Cognitive Loop**: Complete query processing pipeline
14. **Complete Examples**: Full concept blocks and query processing

The goal: **AI that knows what it knows, knows what it doesn't know, and can show its work.**

---

*WMCS Specification v1.0 - Complete*



